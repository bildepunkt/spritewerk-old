<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"bitmap_Animation.js.html":{"id":"bitmap_Animation.js.html","title":"Source: bitmap/Animation.js","body":" Spritewerk Namespaces bitmapshapetext Classes bitmap.Animationbitmap.BitmapCameraCanvasCollectionGroupInputMobilemodule.exportsPreloaderRadioshape.RectangleSpriteStageStatestext.Texttext.TextInputTicker Source: bitmap/Animation.js /** * @class Animation * @memberof bitmap * @desc Describes the src positions and timing of spritesheet a animation * @author Chris Peters * * @param {Array|Integer} srcXSequence A list of (or singular) srcX position(s) * @param {Array|Integer} srcYSequence A list of (or singular) srcY position(s) * @param {Integer} [step=2] The amount of frames between each frame step. This is based on * requestAnimationFrame's 60fps rate. eg: 2 would animate @ 30fps, 3 @ 15fps * etc. * @param {loop} [loop=false] If true, will start the sequence at the initial position when complete and run * until stopped */ export default class Animation { constructor(srcXSequence, srcYSequence, step = 2, loop = false) { this._srcXSequence = srcXSequence; this._srcYSequence = srcYSequence; // at least one sequence must be array this._sequenceLength = Array.isArray(this._srcXSequence) ? this._srcXSequence.length : this._srcYSequence.length; this._step = step; this._frame = 0; this._ticks = 0; this._playing = false; this._loop = loop; } /** * Callback executed if loop set to false on sequence completion * * @method Animation#onComplete */ onComplete() { } /** * @memberof bitmap * @method Animation#play * @param {Boolean} [loop] Whether or not to loop in this sequence instance */ play(loop) { this._loop = loop !== undefined ? loop : this._loop; this._ticks = 0; this._frame = 0; this._playing = true; } /** * @memberof bitmap * @method Animation#update * @returns {null|Object} If animation not playing returns null else returns object containing current srcX/Y values */ update() { if (!this._playing) { return null; } var srcCoords = { srcX: Array.isArray(this._srcXSequence) ? this._srcXSequence[this._frame] : this._srcXSequence, srcY: Array.isArray(this._srcYSequence) ? this._srcYSequence[this._frame] : this._srcYSequence }; this._ticks += 1; this._frame += this._ticks % this._step === 0 ? 1 : 0; if (this._frame &gt;= this._sequenceLength) { if (this._loop) { this._frame = 0; this._ticks = 0; } else { this.stop(); this.onComplete(); } } return srcCoords; } /** * Stops the current animation. Called automatically when sequence ends and loop set to false * * @memberof bitmap * @method Animation#stop */ stop() { this._playing = false; } } × Search results Close "},"bitmap_index.js.html":{"id":"bitmap_index.js.html","title":"Source: bitmap/index.js","body":" Spritewerk Namespaces bitmapshapetext Classes bitmap.Animationbitmap.BitmapCameraCanvasCollectionGroupInputMobilemodule.exportsPreloaderRadioshape.RectangleSpriteStageStatestext.Texttext.TextInputTicker Source: bitmap/index.js /** * @namespace bitmap */ import Bitmap from './Bitmap'; × Search results Close "},"bitmap_Bitmap.js.html":{"id":"bitmap_Bitmap.js.html","title":"Source: bitmap/Bitmap.js","body":" Spritewerk Namespaces bitmapshapetext Classes bitmap.Animationbitmap.BitmapCameraCanvasCollectionGroupInputMobilemodule.exportsPreloaderRadioshape.RectangleSpriteStageStatestext.Texttext.TextInputTicker Source: bitmap/Bitmap.js import Sprite from '../Sprite'; /** * @class Bitmap * @memberof bitmap * @extends Sprite * @desc A sprite that renders an image asset * @author Chris Peters */ export default class Bitmap extends Sprite { constructor(x = 0, y = 0) { super(x, y); this._srcX = 0; this._srcY = 0; this._srcWidth = 0; this._srcHeight = 0; this._imageLoaded = false; this._image = null; this._tiling = 'no-repeat'; this._animations = {}; } /** * @method Bitmap#addAnimation * @param {String} name The animation reference name * @param {Animation} animation The animation instance */ addAnimation(name, animation) { this._animations[name] = animation; } /** * @method Bitmap#playAnimation * @param {String} name The name of the animation to play */ playAnimation(name) { this._playingAnimation = name; this._animations[name].play(); } /** * @method Bitmap#stopAnimation */ stopAnimation() { this._playingAnimation = undefined; this._animations[name].stop(); } /** * Render the entity via context's drawImage * * @method Bitmap#render * @param {Object} context The context object * @param {Integer} factor The 0-1-based model of elapsed time * @param {Integer} ticks Total elapsed ticks */ render(context, factor, ticks) { if (!this._imageLoaded) { return; } if (this._playingAnimation) { const { srcX, srcY } = this._animations[this._playingAnimation].update(ticks); this._srcX = srcX; this._srcY = srcY; } context.save(); super.render(context); if (this._tiling != 'no-repeat') { // TODO cache pattern object const pattern = context.createPattern(this._image, this._tiling); context.rect( 0, 0, this._width * this._scaleX, this._height * this._scaleY ); context.fillStyle = pattern; context.fill(); } else { context.drawImage( this._image, this._srcX, this._srcY, this._srcWidth, this._srcHeight, 0, 0, this._width * this._scaleX, this._height * this._scaleY ); } context.restore(); } /** * Set the iamge to render and sets dimensions if not set * * @method Bitmap#setImage * @param {String} path The image path * @return {Bitmap} */ setImage(path) { var image = new Image(); image.onload = ()=&gt; { this._image = image; if (!this._srcWidth &amp;&amp; !this._srcHeight) { this._srcWidth = this._image.width; this._srcHeight = this._image.height; } if (!this._width &amp;&amp; !this._height) { this._width = this._image.width; this._height = this._image.height; } this._imageLoaded = true; }; image.src = path; return this } /** * Choose how to tile the image. Can be &lt;code&gt;repeat&lt;/code&gt;, &lt;code&gt;repeat-x&lt;/code&gt; * &lt;code&gt;repeat-y&lt;/code&gt; or &lt;code&gt;no-repeat&lt;/code&gt;. Default is &lt;code&gt;no-repeat&lt;/code&gt;. * * @method Bitmap#setTiling * @param {String} val The tiling value * @return {Bitmap} */ setTiling(val) { switch (val) { case 'repeat': case 'repeat-x': case 'repeat-y': case 'no-repeat': this._tiling = val; return this; default: throw new Error( 'Bitmap#setTiling: argument must be either &quot;repeat&quot;, &quot;repeat-x&quot;, &quot;repeat-y&quot;, or &quot;no-repeat&quot;.' ); } } } × Search results Close "},"Sprite.js.html":{"id":"Sprite.js.html","title":"Source: Sprite.js","body":" Spritewerk Namespaces bitmapshapetext Classes bitmap.Animationbitmap.BitmapCameraCanvasCollectionGroupInputMobilemodule.exportsPreloaderRadioshape.RectangleSpriteStageStatestext.Texttext.TextInputTicker Source: Sprite.js /** * @class Sprite * @description Base class for position based objects * @author Chris Peters * * @param {Integer} [x] The initial x position. Default is 0 * @param {Integer} [y] The initial y position. Default is 0 */ class Sprite { constructor(x = 0, y = 0) { this._x = x; this._y = y; this._pivotX = 1; this._pivotY = 1; this._width = 0; this._height = 0; this._scaleX = 1; this._scaleY = 1; this._rotation = 0; /** * The composite operation type. Can be source-atop|source-in|source-out|source-over|destination-atop|destination-in|destination-out|destination-over|lighter|xor|copy * Default is 'source-over' * * @member Sprite#_composite * @type {String} */ this._composite = Sprite._compositeDefault; this._opacity = 1; } /** * @method Sprite.getCompositeDefault * @return {String} */ static getCompositeDefault() { return Sprite._compositeDefault; } /** * @return {Object} The bounding area */ getBoundingArea() { return { maxX: this._x + (this._width * this._scaleX), maxY: this._y + (this._height * this._scaleY), minX: this._x, minY: this._y }; } /** * @method Sprite#getComposite * @return {String} */ getComposite() { return this._composite; } /** * @method Sprite#getHeight * @return {Integer} */ getHeight() { return this._height; } /** * @method Sprite#getOpacity * @return {Float} */ getOpacity() { return this._opacity; } /** * @method Sprite#getPivotX * @return {Integer} */ getPivotX() { return this._pivotX; } /** * @method Sprite#getPivotY * @return {Integer} */ getPivotY() { return this._pivotY; } /** * @method Sprite#getRotation * @return {Float} */ getRotation() { return this._rotation; } /** * @method Sprite#getRotation * @return {Float} */ getRotationRadians() { return this._rotation; } /** * @method Sprite#getScaleX * @return {Integer} */ getScaleX() { return this._scaleX; } /** * @method Sprite#getScaleY * @return {Integer} */ getScaleY() { return this._scaleY; } /** * @method Sprite#getSrcHeight * @return {Integer} */ getSrcHeight() { return this._srcHeight; } /** * @method Sprite#getSrcWidth * @return {Integer} */ getSrcWidth() { return this._srcWidth; } /** * @method Sprite#getSrcX * @return {Integer} */ getSrcX() { return this._srcX; } /** * @method Sprite#getSrcY * @return {Integer} */ getSrcY() { return this._srcY; } /** * @method Sprite#getWidth * @return {Integer} */ getWidth() { return this._width; } /** * @method Sprite#getX * @return {Integer} */ getX() { return this._x; } /** * @method Sprite#getY * @return {Integer} */ getY() { return this._y; } /** * @method Sprite#render * @param {Object} context The canvas' context */ render(context, factor, ticks) { context.translate( this._x + this._pivotX, this._y + this._pivotY ); context.scale(this._scaleX, this._scaleY); if (this._rotation !== 0) { context.translate(-this._pivotX, -this._pivotY); context.rotate(this._rotation); context.translate(-this._pivotX, -this._pivotY); } } /** * * @method Sprite#setComposite * @param {Integer} val The composite value * @return {Sprite} */ setComposite(val) { this._composite = val; return this; } /** * * @method Sprite#setHeight * @param {Integer} val The height value * @return {Sprite} */ setHeight(val) { this._height = val; return this; } /** * * @method Sprite#setOpacity * @param {Float} val The opacity value * @return {Sprite} */ setOpacity(val) { this._opacity = val; return this; } /** * @method Sprite#setPivotX * @param {Float} val The opacity value * @return {Sprite} */ setPivotX(val) { this._pivotX = val; return this; } /** * @method Sprite#setPivotY * @param {Float} val The opacity value * @return {Sprite} */ setPivotY(val) { this._pivotY = val; return this; } /** * * @method Sprite#setRotation * @param {Integer} val The rotation value * @return {Sprite} */ setRotation(val) { this._rotation = val * Math.PI / 180; return this; } /** * * @method Sprite#setScaleX * @param {Integer} val The scaleX value * @return {Sprite} */ setScaleX(val) { this._scaleX = val; return this; } /** * * @method Sprite#setScaleY * @param {Integer} val The scaleY value * @return {Sprite} */ setScaleY(val) { this._scaleY = val; return this; } /** * * @method Sprite#setSrcHeight * @param {Integer} val The srcHeight value * @return {Sprite} */ setSrcHeight(val) { this._srcHeight = val; return this; } /** * * @method Sprite#setSrcWidth * @param {Integer} val The srcWidth value * @return {Sprite} */ setSrcWidth(val) { this._srcWidth = val; return this; } /** * * @method Sprite#setSrcX * @param {Integer} val The srcX value * @return {Sprite} */ setSrcX(val) { this._srcX = val; return this; } /** * * @method Sprite#setSrcY * @param {Integer} val The srcY value * @return {Sprite} */ setSrcY(val) { this._srcY = val; return this; } /** * * @method Sprite#setWidth * @param {Integer} val The width value * @return {Sprite} */ setWidth(val) { this._width = val; return this; } /** * * @method Sprite#setComposite * @param {Integer} val The x value * @return {Sprite} */ setX(val) { this._x = val; return this; } /** * * @method Sprite#setY * @param {Integer} val The y value * @return {Sprite} */ setY(val) { this._y = val; return this; } /** * Add/Subtract current x/y values. Assign any non-number to leave value the same. * * @method Sprite#translate * @param {Integer} [x] * @param {Integer} [y] * @returns {Sprite} */ translate(x, y) { if (typeof x === 'number') { this._x += x; } if (typeof y === 'number') { this._y += y; } return this; } } /** * @member Sprite._compositeDefault * @type {String} */ Sprite._compositeDefault = 'source-over'; export default Sprite; × Search results Close "},"Camera.js.html":{"id":"Camera.js.html","title":"Source: Camera.js","body":" Spritewerk Namespaces bitmapshapetext Classes bitmap.Animationbitmap.BitmapCameraCanvasCollectionGroupInputMobilemodule.exportsPreloaderRadioshape.RectangleSpriteStageStatestext.Texttext.TextInputTicker Source: Camera.js /** * @class Camera * @description Decides what gets rendered * @author Chris Peters */ export default class Camera { constructor(x = 0, y = 0) { this._x = 0; this._y = 0; } /** * @method Camera#getX * @return {Integer} */ getX() { return this._x; } /** * @method Camera#getY * @return {Integer} */ getY() { return this._y; } /** * @method Camera#setX * @param {Integer} val The x value * @return {Camera} */ setX(val) { this._x = val; return this; } /** * @method Camera#setY * @param {Integer} val The y value * @return {Camera} */ setY(val) { this._y = val; return this; } } × Search results Close "},"Canvas.js.html":{"id":"Canvas.js.html","title":"Source: Canvas.js","body":" Spritewerk Namespaces bitmapshapetext Classes bitmap.Animationbitmap.BitmapCameraCanvasCollectionGroupInputMobilemodule.exportsPreloaderRadioshape.RectangleSpriteStageStatestext.Texttext.TextInputTicker Source: Canvas.js /** * @class Canvas * @description Handles rendering entities onto the canvas element. * @author Chris Peters * * @param {HTMLElement} canvas The active canvas element * @param {Camera} camera The camera instance */ export default class Canvas { constructor(canvas, camera) { this._canvas = canvas; this._camera = camera; this._context = this._canvas.getContext('2d'); this.setImageSmoothing(true); } /** * Clears the entire canvas and optionally fills with a color * * @method Canvas#clear * @param {String} [color] If passed, will fill the canvas with the color value */ clear(color) { this._context.clearRect(0, 0, this._canvas.width, this._canvas.height); if (color) { this._context.save(); this._context.fillStyle = color; this._context.fillRect(0, 0, this._canvas.width, this._canvas.height); this._context.restore(); } } /** * Returns the context object * * @method Canvas#getContext * @return {Object} The 2D context object */ getContext() { return this._context; } /** * Offsets canvas based on camera and calls an entity's render method passing the context. * Saves and restores context and beginning and end of operation. * * @method Canvas#render * @param {Object} entity [description] */ render(entity, factor, ticks) { this._context.save(); this._context.translate(-this._camera.getX(), -this._camera.getY()); entity.render(this._context, factor, ticks); this._context.restore(); } /** * Set the context image smoothing * * @method Canvas#setImageSmoothing * @param {Boolean} val The image smoothing value */ setImageSmoothing(val) { this._imageSmoothingEnabled = val; this._context.imageSmoothingEnabled = this._imageSmoothingEnabled; this._context.mozImageSmoothingEnabled = this._imageSmoothingEnabled; this._context.webkitImageSmoothingEnabled = this._imageSmoothingEnabled; this._context.msImageSmoothingEnabled = this._imageSmoothingEnabled; return this; } } × Search results Close "},"Collection.js.html":{"id":"Collection.js.html","title":"Source: Collection.js","body":" Spritewerk Namespaces bitmapshapetext Classes bitmap.Animationbitmap.BitmapCameraCanvasCollectionGroupInputMobilemodule.exportsPreloaderRadioshape.RectangleSpriteStageStatestext.Texttext.TextInputTicker Source: Collection.js /** * @class Collection * @description Provides the sortable, iterable storage of entities that are * gettable, settable, sortable, removable, etcera(ble) by name * @author Chris Peters */ export default class Collection { constructor() { /** * @member {Array} The sorted list * @private */ this._items = []; } /** * Returns the item { name, item } object * * @param {String} name * @return {Object} * @private */ _getRawItem(name) { let item; this._rawEach(function(iterItem, i, iterName) { if (name === iterName) { item = iterItem; return false; } }); return item; } /** * Iterates the collection's sorted items. The raw item, index, name, and the * list being iterated are supplied to the provided function * * @param {Function} fn * @private */ _rawEach(fn) { for(var i = 0, len = this._items.length; i &lt; len; i += 1) { if (fn(this._items[i], i, this._items[i].name, this._items) === false) { break; } } } /** * Add an item with optional name * * @param {Any} item The item to add * @param {String} [name] The optional name of the item * @return {Collection} */ addItem(item, name) { name = name || ''; this._items.push({ item, name }); return this; } /** * Add multiple items * * @param {...Object} items Can be the object itself or an object containing the entity and it's name * eg: &lt;code&gt;{ item: Entity, name: 'entityName' }&lt;/code&gt; * @return {Collection} */ addItems(...items) { for (let item of items) { if (typeof item.item === 'object' &amp;&amp; typeof item.name === 'string') { // if item has item/name structure this.addItem(item.item, item.name); } else { // for convenience allow user to add just item this.addItem(item); } } return this; } /** * Iterates the collection's sorted items. The item, index, and name are supplied * to the provided function * * @param {Function} fn The function to execute on the iterable * @param {Object} [scope] The scope with which to execute the function */ each(fn, scope) { fn = scope ? fn.bind(scope) : fn; for (var i = 0, len = this._items.length; i &lt; len; i++) { let item = this._items[i]; if (fn(item.item, i, item.name) === false) { break; } } } /** * iterates items and return the ones that meet criteria * * @param {Function} fn Truth predicate * @param {Object} [scope] The scope with which to execute the function * @return {Array} */ filter(fn, scope) { let filteredItems = []; this.each((item, i, name)=&gt; { let predicate = fn(item, i, name); if (predicate) { filteredItems.push(item); } }, scope); return filteredItems; } /** * Returns a list of just the items * * @return {Array} */ getItemArray() { return this._items.map((item)=&gt; { return item.item; }); } /** * Returns an existing item by name, or undefined if the name is not found * * @param {String} name The name of the item * @return {Any} */ getItem(name) { let item; this.each((iterItem, i, iterName)=&gt; { if (name === iterName) { item = iterItem; return false; } }); return item; } /** * Returns an existing item by index * * @param {Integer} index * @return {Any} */ getItemAt(index) { return this._items[index].item; } /** * Returns the count of items in collection * * @return {Integer} */ getItemCount() { return this._items.length; } /** * Returns an item's current index * * @param {String} name * @return {Integer} */ getItemIndex(name) { let index; this.each((iterItem, i, iterName)=&gt; { if (name === iterName) { index = i; return false; } }); return index; } /** * Removes all items from collection */ removeAllItems() { this._items = []; } /** * Removes an object by name * * @method SW.Collection.prototype.removeItem * @param {String} name * @return {Boolean} Returns true if item removed, false if not */ removeItem(name) { var removed = false; this._rawEach((iterItem, i, iterName, items)=&gt; { if (name === iterName) { iterItem = null; items.splice(i, 1); removed = true; // break out of loop return false; } }); return removed; } /** * Assigns a new value to an existing item * * @param {String} name The name of the object to modify * @param {Any} value The new value */ setItem(name, value) { this._rawEach((iterItem, i, iterName)=&gt; { if (name === iterName) { iterItem.item = value; // break out of loop return false; } }); } /** * Moves item to new index * * @param {String} name The name of the object being moved * @param {Integer} index The item's new index */ setItemIndex(name, index) { let item; let currentIndex = this.getItemIndex(name); if (index === currentIndex) { return; } item = this._getRawItem(name); this.removeItem(name); this._items.splice(index, 0, item); } } × Search results Close "},"Group.js.html":{"id":"Group.js.html","title":"Source: Group.js","body":" Spritewerk Namespaces bitmapshapetext Classes bitmap.Animationbitmap.BitmapCameraCanvasCollectionGroupInputMobilemodule.exportsPreloaderRadioshape.RectangleSpriteStageStatestext.Texttext.TextInputTicker Source: Group.js import Collection from './Collection'; import Sprite from './Sprite'; /** * @class Group * @description Provides a transformation hierarchy for {@link Collection}s * @extends Collection * @requires Sprite * @author Chris Peters * */ export default class Group extends Collection { constructor() { super(); } /** * Renders all children recursively on top of own transformation stack * * @method Group#render * @param {Object} context The 2d context object */ render(context, factor, ticks) { context.save(); this.each((item)=&gt; { item.render(context, factor, ticks); }, this); context.restore(); } } × Search results Close "},"Input.js.html":{"id":"Input.js.html","title":"Source: Input.js","body":" Spritewerk Namespaces bitmapshapetext Classes bitmap.Animationbitmap.BitmapCameraCanvasCollectionGroupInputMobilemodule.exportsPreloaderRadioshape.RectangleSpriteStageStatestext.Texttext.TextInputTicker Source: Input.js import Radio from './Radio'; import keycodes from './lib/keycodes'; /** * @class Input * @description A module for handling keyboard, mouse, and touch events on the canvas * @author Chris Peters * @requires Radio * @requires lib/keycodes * * @param {HTMLEntity} canvas The canvas element to interact with * @param {Object} [opts] * @param {Boolean} [opts.canvasFit] Set to true if using css to fit the canvas in the viewport * @param {Boolean} [opts.listenForMouse] Whether or not to listen for mouse events * @param {Boolean} [opts.listenForTouch] Whether or not to listen for touch events * @param {Boolean} [opts.listenForKeyboard] Whether or not to listen for keyboard events * @param {Object} [opts.window] window object for testing * @param {Object} [opts.document] document object for testing */ export default class Input { constructor(canvas, opts = {}) { // options this._canvas = canvas; this._canvasFit = opts.canvasFit || true; this._listenForMouse = opts.listenForMouse || true; this._listenForTouch = opts.listenForTouch || false; this._listenForKeyboard = opts.listenForKeyboard || true; this._window = opts.window || window; this._document = opts.document || document; this._uiEvents = { DBL_CLICK: 'dblclick', DBL_TAP: 'dbltap', DRAG: 'drag', DRAG_END: 'dragend', DRAG_START: 'dragstart', CLICK: 'click', TAP: 'tap', MOUSE_DOWN: 'mousedown', MOUSE_UP: 'mouseup', TOUCH_START: 'touchstart', TOUCH_END: 'touchend', MOUSE_MOVE: 'mousemove', TOUCH_MOVE: 'touchmove', KEY_UP: 'keyup', KEY_DOWN: 'keydown' }; // listeners values are arrays of objects containing handlers and (optional) targets // eg: this._listeners.keyup = [{ // handler: function () {...}, // target: { name: 'foo', x: 32, y: 64, ...} // }]; this._listeners = {}; for (let key in this._uiEvents) { this._listeners[this._uiEvents[key]] = []; } this._keycodes = keycodes; this._canDrag = false; this._isDragging = false; this._keysDown = {}; this._userHitTestMethod = null; this._queuedEvents = []; if (this._listenForKeyboard) { this._addKeyboardListeners(); } if (this._listenForMouse) { this._addMouseListeners(); } if (this._listenForTouch) { this._addTouchListeners(); } this._onTick = this._onTick.bind(this); Radio.tuneIn(this._document, 'tick', this._onTick); } /** * Adds keyboard listeners * * @method Input#_addKeyboardListeners * @private */ _addKeyboardListeners() { let events = ['keyup', 'keydown']; for (let event of events) { Radio.tuneIn(this._canvas, event, this._handleKeyboard.bind(this)); } } /** * Adds mouse listeners * * @method Input#_addMouseListeners * @private */ _addMouseListeners() { let events = ['click', 'dblclick', 'mousedown', 'mouseup', 'mousemove']; for (let event of events) { Radio.tuneIn(this._canvas, event, this._handleMouseAndTouch.bind(this)); } } /** * Adds touch listeners * * @method Input#_addTouchListeners * @private */ _addTouchListeners() { let events = ['tap', 'dbltap', 'touchstart', 'touchend', 'touchmove']; for (let event of events) { Radio.tuneIn(this._canvas, event, this._handleMouseAndTouch.bind(this)); } } /** * get the scale ratio of the canvas based on with/heght attrs and css width/height * * @method Input#_getScaleFactor * @return {Float} */ _getScaleFactor() { let factor = 1; let canvasWidth; if (this._canvas.style.width) { canvasWidth = parseInt(this._canvas.style.width, 10); factor = canvasWidth / this._canvas.width; } return 100 / factor / 100; } /** * Checks if point is inside rectangle * * @method Input#_hitTest * @param {Integer} x [description] * @param {Integer} y [description] * @param {Object} boundingBox [description] * @return {Boolean} */ _hitTest(x, y, boundingBox) { return x &gt;= boundingBox.minX &amp;&amp; x &lt;= boundingBox.maxX &amp;&amp; y &gt;= boundingBox.minY &amp;&amp; y &lt;= boundingBox.maxY; } /** * Handler for DOM events. Creates custom event object with helpful properties * * @method Input#_handleKeyboard * @param {object} inputEvent the DOM input event object * @private */ _handleKeyboard(inputEvent) { inputEvent.preventDefault(); let keyName = this._keycodes[inputEvent.keyCode]; let event = { domEvent: inputEvent, type: inputEvent.type, keyCode: inputEvent.keyCode, keyName: typeof keyName === 'object' &amp;&amp; keyName.length ? keyName[0] : keyName }; switch (event.type) { case this._uiEvents.KEY_DOWN: this._keysDown[keyName] = inputEvent.keyCode; break; case this._uiEvents.KEY_UP: delete this._keysDown[keyName]; break; } event.keysDown = this.getKeysDown(); this._queuedEvents.push(event); } /** * Handler for DOM events. Creates custom event object with helpful properties * Creates event objects with x/y coordinates based on scaling and absX/absY for * absolute x/y regardless of scale offset * Only uses first touch event, thus not currently supporting multi-touch * * @method Input# * @param {object} inputEvent The DOM input event object */ _handleMouseAndTouch(inputEvent) { inputEvent.preventDefault(); let scaleFactor = this._canvasFit ? this._getScaleFactor() : 1; let event = { domEvent: inputEvent, type: inputEvent.type }; this._queuedEvents.push(event); if (inputEvent.hasOwnProperty('touches')) { event.absX = inputEvent.touches[0].pageX - this._canvas.offsetLeft; event.absY = inputEvent.touches[0].pageY - this._canvas.offsetTop; } else { event.absX = inputEvent.pageX - this._canvas.offsetLeft; event.absY = inputEvent.pageY - this._canvas.offsetTop; } // coordinate positions relative to canvas scaling event.x = Math.round(event.absX * scaleFactor); event.y = Math.round(event.absY * scaleFactor); switch (event.type) { case this._uiEvents.MOUSE_DOWN: case this._uiEvents.TOUCH_START: this._canDrag = true; break; case this._uiEvents.MOUSE_UP: case this._uiEvents.TOUCH_END: this._canDrag = false; if (this._isDragging) { this._isDragging = false; this._queuedEvents.push(Object.assign({}, event, { type: this._uiEvents.DRAG_END })); } break; case this._uiEvents.MOUSE_MOVE: case this._uiEvents.TOUCH_MOVE: if (this._canDrag) { if (!this._isDragging) { this._isDragging = true; this._queuedEvents.push(Object.assign({}, event, { type: this._uiEvents.DRAG_START })); } this._queuedEvents.push(Object.assign({}, event, { type: this._uiEvents.DRAG })); } break; } } /** * Checks for duplicate handler in the listener tyoe being added * * @method Input#_isDuplicateHandler * @param {Function} handler The handler to check * @param {Array} handlers The handlers of the listener type being added * @return {Boolean} * @private */ _isDuplicateHandler(handler, handlerObjects) { let dup = false; for (let handlerObject of handlerObjects) { if (handler === handlerObject.handler) { dup = true; break; } } return dup; } /** * Triggers all queued events. Passes the factor and ticks from {@link Ticker} * * @method Input#_onTick * @param {Object} e The event object */ _onTick(e) { for (let event of this._queuedEvents) { this._triggerHandlers(event); } this._queuedEvents = []; } /** * executes handlers of the given event's type * * @method Input#_triggerHandlers * @param {object} event * @private */ _triggerHandlers(event) { for (let handlerObject of this._listeners[event.type]) { if (handlerObject.target) { let hitTest = this._userHitTestMethod || this._hitTest; if (hitTest(event.x, event.y, handlerObject.target.getBoundingArea())) { event.target = handlerObject.target; // if event was bound with a target trigger handler ONLY if target hit handlerObject.handler(event); } } else { handlerObject.handler(event); } } } /** * Adds a handler to a {@link Sprite} for the given event type * * @method Input#addListener * @param {string} type The event type * @param {function} handler The function to execute when event triggered * @param {object} [target] The target to check event trigger against * @return {boolean} Returns true if added and false if callback already exists */ addListener(type, handler, target) { let handlerObjects = this._listeners[type]; let dup; if (! handlerObjects) { throw new TypeError(`Event type &quot;${type}&quot; does not exist.`); } if (handlerObjects.length) { dup = this._isDuplicateHandler(handler, handlerObjects); } if (!dup) { handlerObjects.push({ handler, target }); return true; } return false; } /** * Removes matching handler if found * * @method Input#removeListener * @param {string} type the event type * @param {function} handler the handler to remove * @return {boolean} removed Returns true if removed and otherwise false */ removeListener(type, handler) { let handlers = this._listeners[type]; let removed = false; if (! handlers) { throw new TypeError(`Event type &quot;${type}&quot; does not exist.`); } for (let i = 0, len = handlers.length; i &lt; len; i++) { let handlerObject = handlers[i]; if (handlerObject.handler === handler) { handlers.splice(i, 1); removed = true; break; } } return removed; } /** * returns an object of the keys currently being pressed * eg: &lt;code&gt;{ LEFT_ARROW: 37, UP_ARROW: 38 }&lt;/code&gt; * * @method Input#getKeysDown * @return {Object} */ getKeysDown() { return this._keysDown; } /** * Allows user to set a custom hit test method * * @method Input#setHitTestMethod * @param {Function} fn The user's hit test method */ setHitTestMethod(fn) { if (typeof fn !== 'function') { throw new TypeError('Input#setHitTestMethod parameter must be a function'); } this._userHitTestMethod = fn; } } × Search results Close "},"Mobile.js.html":{"id":"Mobile.js.html","title":"Source: Mobile.js","body":" Spritewerk Namespaces bitmapshapetext Classes bitmap.Animationbitmap.BitmapCameraCanvasCollectionGroupInputMobilemodule.exportsPreloaderRadioshape.RectangleSpriteStageStatestext.Texttext.TextInputTicker Source: Mobile.js /** * @class Mobile * @description A class with helpers for making the application play nice with mobile browsers * @author Chris Peters */ export default class Mobile { /** * [addMetaTags description] * @method Mobile.addMetaTags * @param {Object} doc [description] */ static addMetaTags(doc = document) { var head = doc.head; var meta = doc.createElement('meta'); meta.name = 'viewport'; meta.content = 'width=device-width, user-scalable=no, ' + 'initial-scale=1, maximum-scale=1, user-scalable=0'; head.appendChild(meta); meta = doc.createElement('meta'); meta.name = 'apple-mobile-web-app-capable'; meta.content = 'yes'; head.appendChild(meta); meta = doc.createElement('meta'); meta.name = 'mobile-web-app-capable'; meta.content = 'yes'; head.appendChild(meta); } } × Search results Close "},"lib_keycodes.js.html":{"id":"lib_keycodes.js.html","title":"Source: lib/keycodes.js","body":" Spritewerk Namespaces bitmapshapetext Classes bitmap.Animationbitmap.BitmapCameraCanvasCollectionGroupInputMobilemodule.exportsPreloaderRadioshape.RectangleSpriteStageStatestext.Texttext.TextInputTicker Source: lib/keycodes.js /** * */ export default { 8: 'BACKSPACE', 9: 'TAB', 13: 'ENTER', 16: 'SHIFT', 17: 'CTRL', 18: 'ALT', 19: 'PAUSE_BREAK', 20: 'CAPS_LOCK', 27: 'ESCAPE', 33: 'PAGE_UP', 34: 'PAGE_DOWN', 35: 'END', 36: 'HOME', 37: 'LEFT_ARROW', 38: 'UP_ARROW', 39: 'RIGHT_ARROW', 40: 'DOWN_ARROW', 45: 'INSERT', 46: 'DELETE', 48: [0,')'], 49: [1,'!'], 50: [2,'@'], 51: [3,'#'], 52: [4,'$'], 53: [5,'%'], 54: [6,'^'], 55: [7,'&amp;'], 56: [8,'*'], 57: [9,'('], 65: 'A', 66: 'B', 67: 'C', 68: 'D', 69: 'E', 70: 'F', 71: 'G', 72: 'H', 73: 'I', 74: 'J', 75: 'K', 76: 'L', 77: 'M', 78: 'N', 79: 'O', 80: 'P', 81: 'Q', 82: 'R', 83: 'S', 84: 'T', 85: 'U', 86: 'V', 87: 'W', 88: 'X', 89: 'Y', 90: 'Z', 91: 'LEFT_WINDOW_KEY', 92: 'RIGHT_WINDOW_KEY', 93: 'SELECT_KEY', 96: 'NUM_PAD_0', 97: 'NUM_PAD_1', 98: 'NUM_PAD_2', 99: 'NUM_PAD_3', 100: 'NUM_PAD_4', 101: 'NUM_PAD_5', 102: 'NUM_PAD_6', 103: 'NUM_PAD_7', 104: 'NUM_PAD_8', 105: 'NUM_PAD_9', 106: 'NUM_PAD_ASTERISK', 107: 'NUM_PAD_PLUS', 109: 'NUM_PAD_MINUS', 111: 'NUM_PAD_FOWARD_SLASH', 112: 'F1', 113: 'F2', 114: 'F3', 115: 'F4', 116: 'F5', 117: 'F6', 118: 'F7', 119: 'F8', 120: 'F9', 121: 'F10', 122: 'F11', 123: 'F12', 144: 'NUM_LOCK', 145: 'SCROLL_LOCK', 186: [';',':'], 187: ['=','+'], 188: [',','&lt;'], 189: ['-','_'], 190: ['.','&gt;'], 191: ['/','?'], 192: ['`','~'], 219: ['[','{'], 220: ['\\\\','|'], 221: [']','}'], 222: ['\\'','&quot;'] }; × Search results Close "},"tween_Tween.js.html":{"id":"tween_Tween.js.html","title":"Source: tween/Tween.js","body":" Spritewerk Namespaces bitmapshapetext Classes bitmap.Animationbitmap.BitmapCameraCanvasCollectionGroupInputMobilemodule.exportsPreloaderRadioshape.RectangleSpriteStageStatestext.Texttext.TextInputTicker Source: tween/Tween.js import easing from '../lib/easing'; /** * */ export default class Tween { constructor() { this._entity = null; this._from = null; this._to = null; this._ms = null; this._easing = null; this._currentFrame = null; this._startFrame = null; this._endFrame = null; this._totalFrames = this._ms / (1000 / 60); this._complete = false; } onComplete() { // callback } update(frame) { this._currentFrame = frame; this._startFrame = this._startFrame === null ? this._currentFrame : this._startFrame; this._endFrame = this._endFrame === null ? this._currentFrame + this._totalFrames : this._endFrame; if (this._currentFrame &lt; this._endFrame &amp;&amp; !this._complete) { if (!this._easing) { this._easing = 'linear'; } for(let prop in this._from) { this._entity[prop] = easing[this._easing]( this._currentFrame, this._from[prop], this._to[prop] - this._from[prop], this._totalFrames ); } } else { this._complete = true; this.onComplete(); } } } × Search results Close "},"Preloader.js.html":{"id":"Preloader.js.html","title":"Source: Preloader.js","body":" Spritewerk Namespaces bitmapshapetext Classes bitmap.Animationbitmap.BitmapCameraCanvasCollectionGroupInputMobilemodule.exportsPreloaderRadioshape.RectangleSpriteStageStatestext.Texttext.TextInputTicker Source: Preloader.js /** * @class Preloader * @desc Preloads a list of image, video, and audio files * @author Chris Peters */ class Preloader { /** * Parses file types and preloads them via element tags * @method Preloader.load * @param {...String|Array} paths File paths to preload */ static load(...paths) { Preloader.loaded = 0; Preloader.total = paths.length; // if array is passed if (paths.length &amp;&amp; Array.isArray(paths[0])) { paths = paths[0]; } for (let path of paths) { if (Preloader._isImage(path)) { var img = new Image(); img.src = path; img.addEventListener('load', Preloader.handleLoad, false); img.addEventListener('error', Preloader.error, false); } else if (Preloader._isAudio(path)) { var audio = new Audio(); audio.src = path; audio.addEventListener('canplaythrough', Preloader.handleLoad, false); audio.addEventListener('error', Preloader.error, false); } else if (Preloader._isVideo(path)) { var video = new Video(); video.src = path; video.addEventListener('canplaythrough', Preloader.handleLoad, false); video.addEventListener('error', Preloader.error, false); } } } /** * Returns if file has audio extension * * @method Preloader._isAudio * @param {String} path The file path * @return {Boolean} */ static _isAudio(path) { return path.indexOf('.mp3') &gt; 0 || path.indexOf('.wav') &gt; 0 || path.indexOf('.ogg') &gt; 0; } /** * Returns if file has image extension * * @method Preloader._isImage * @param {String} path The file path * @return {Boolean} */ static _isImage(path) { return path.indexOf('.png') &gt; 0 || path.indexOf('.jpg') &gt; 0 || path.indexOf('.jpeg') &gt; 0 || path.indexOf('.gif') &gt; 0 || path.indexOf('.bmp') &gt; 0; } /** * Returns if file has video extension * * @method Preloader._isVideo * @param {String} path The file path * @return {Boolean} */ static _isVideo(path) { return path.indexOf('.webm') &gt; 0 || path.indexOf('.mp4') &gt; 0 || path.indexOf('.ogv') &gt; 0; } /** * Removes event listener when loaded or errored * * @method Preloader.removeListener * @param {HTMLEntity} el The html element */ static removeListener(el) { var type = el.tagName.toLowerCase(); switch (type) { case 'img': el.removeEventListener('load', Preloader.handleLoad, false); el.removeEventListener('error', Preloader.error, false); break; case 'audio': el.removeEventListener('canplaythrough', Preloader.handleLoad, false); el.removeEventListener('error', Preloader.error, false); break; } } /** * Increments loaded count and calls complete or update based on count * * @method Preloader.handleLoad * @param {Object} e The event object */ static handleLoad(e) { Preloader.removeListener(e.currentTarget); Preloader.loaded += 1; if (Preloader.loaded === Preloader.total) { Preloader.complete(); } else { Preloader.update(Preloader.loaded, Preloader.total); } } /** * Callback executed every time an asset has loaded. It gets passed loaded &amp; total * which is useful for displaying percentage feedback. * * @method Preloader.update * @param {Integer} loaded * @param {Integer} total */ static update() {} /** * Callback executed when loading complete * * @method Preload.complete */ static complete() {} /** * Handles errors * * @method Preloader.error * @param {Object} e The event object */ static error(e) { console.warn(e.status); } } Preloader.loaded = 0; Preloader.total = 0; export default Preloader; × Search results Close "},"Radio.js.html":{"id":"Radio.js.html","title":"Source: Radio.js","body":" Spritewerk Namespaces bitmapshapetext Classes bitmap.Animationbitmap.BitmapCameraCanvasCollectionGroupInputMobilemodule.exportsPreloaderRadioshape.RectangleSpriteStageStatestext.Texttext.TextInputTicker Source: Radio.js /** * @class Radio * @description Wrapper for event listening, removing, &amp; dispatching. Currently only supports broadcasting Custom and Mouse events * @author Chris Peters */ export default class Radio { /** * @method Radio.tuneIn * @param {Any} target * @param {String} event * @param {Function} callback */ static tuneIn(target, event, callback) { target.addEventListener(event, callback, false); } /** * @method Radio.tuneOut * @param {Any} target * @param {String} event * @param {Function} callback */ static tuneOut(target, event, callback) { target.removeEventListener(event, callback, false); } /** * * @method Radio.broadcast * @param {Any} target * @param {String} event * @param {Object} data */ static broadcast(target, event, data) { let evt; switch(event) { case 'click': case 'dblclick': case 'mousedown': case 'mouseup': case 'mousemove': evt = new MouseEvent(event, { 'view': window, 'bubbles': true, 'cancelable': false }); break; default: evt = new CustomEvent(event, { detail: data }); break; } target.dispatchEvent(evt); } } × Search results Close "},"shape_index.js.html":{"id":"shape_index.js.html","title":"Source: shape/index.js","body":" Spritewerk Namespaces bitmapshapetext Classes bitmap.Animationbitmap.BitmapCameraCanvasCollectionGroupInputMobilemodule.exportsPreloaderRadioshape.RectangleSpriteStageStatestext.Texttext.TextInputTicker Source: shape/index.js /** * @namespace shape */ import Rectangle from './Rectangle'; × Search results Close "},"shape_Rectangle.js.html":{"id":"shape_Rectangle.js.html","title":"Source: shape/Rectangle.js","body":" Spritewerk Namespaces bitmapshapetext Classes bitmap.Animationbitmap.BitmapCameraCanvasCollectionGroupInputMobilemodule.exportsPreloaderRadioshape.RectangleSpriteStageStatestext.Texttext.TextInputTicker Source: shape/Rectangle.js import Sprite from '../Sprite'; /** * @class Rectangle * @memberof shape * @extends Sprite * @desc A sprite that renders as a rectangle * @author Chris Peters */ export default class Rectangle extends Sprite { constructor(x = 0, y = 0) { super(x, y); this._fill = '#000'; this._stroke = ''; } /** * * @memberof shape * @method Rectangle#render * @param {Object} context The CanvasRenderingContext2D object * @param {Integer} factor The 0-1-based model of elapsed time * @param {Integer} ticks Total elapsed ticks */ render(context, factor, ticks) { context.save(); super.render(context, factor, ticks); if (this._fill) { context.fillStyle = this._fill; context.fillRect(0, 0, this._width, this._height); } if (this._stroke) { context.strokeStyle = this._stroke; context.strokeRect(0, 0, this._width, this._height); } context.restore(); } /** * [setFill description] * * @memberof shape * @method Rectangle#setFill * @param {String} val The fill color hex, rgb, rgba, etc. */ setFill(val) { this._fill = val; return this; } /** * [setStroke description] * * @memberof shape * @method Rectangle#setStroke * @param {String} val The stroke color hex, rgb, rgba, etc. */ setStroke(val) { this._stroke = val; return this; } } × Search results Close "},"Stage.js.html":{"id":"Stage.js.html","title":"Source: Stage.js","body":" Spritewerk Namespaces bitmapshapetext Classes bitmap.Animationbitmap.BitmapCameraCanvasCollectionGroupInputMobilemodule.exportsPreloaderRadioshape.RectangleSpriteStageStatestext.Texttext.TextInputTicker Source: Stage.js /** * @class Stage * @description Creates and handles the canvas element. included in the options * parameter is optional dependency injection used for testing against * a virtual dom. * @author Chris Peters * * @param {Integer} [width] The width of the canvas * @param {Integer} [height] The height of the canvas * @param {Object} [opts] Stage options * @param {HTMLElement} [opts.parentEl] The element with which to attach the canvas. * If none given the body is used. * @param {String} [opts.bgColor] The parent element's bg color * @param {Object} [opts.document] For testing * @param {Object} [opts.window] For testing * @param {Boolean} [opts.fill] Set to false to not maximally fill viewport. * Default is true. */ export default class Stage { constructor(width = 800, height = 600, opts = {}) { this._fill = opts.fill === undefined ? true : opts.fill; this._width = width; this._height = height; this._document = opts.document || document; this._window = opts.window || window; this._parentEl = opts.parentEl || this._document.body; this._document.documentElement.style.backgroundColor = opts.bgColor; this._createStageElements(); this._window.addEventListener('resize', this._handleResize.bind(this)); this._window.addEventListener('orientationchange', this._handleResize.bind(this)); this._handleResize(); } _createStageElements() { this._stage = this._document.createElement('div'); this._parentEl.appendChild(this._stage); this._textfield = this._document.createElement('input'); this._textfield.type = 'text'; this._textfield.style.position = 'absolute'; this._textfield.style.top = '-999px'; // TODO verify value 'none' this._textfield.autocapitalize = 'none'; this._textfield.id = 'textfield'; this._stage.appendChild(this._textfield); this._video = this._document.createElement('video'); this._video.id ='video'; this._video.style.position = 'absolute'; this._stage.appendChild(this._video); this._canvas = this._document.createElement('canvas'); this._canvas.width = this._width; this._canvas.height = this._height; this._canvas.style.position = 'absolute'; this._stage.appendChild(this._canvas); } /** * Calls _resizeElement for stage elements * * @method Stage#_handleResize */ _handleResize() { this._resizeElement(this._canvas); this._resizeElement(this._video); } /** * Decides how to handle resize based on options * * @method Stage#_resizeElement * @param {HTMLEntity} el The element to resize */ _resizeElement(el) { if (this._fill) { let { top, left, width, height } = Stage.fill( this._width, this._height, this._window.innerWidth, this._window.innerHeight ); el.style.top = `${Math.round(top)}px`; el.style.left = `${Math.round(left)}px`; el.style.width = `${Math.round(width)}px`; el.style.height = `${Math.round(height)}px`; } else { let { top, left } = Stage.center( this._width, this._height, this._window.innerWidth, this._window.innerHeight ); el.style.top = `${Math.round(top)}px`; el.style.left = `${Math.round(left)}px`; } } /** * Returns the canvas element * * @method Stage#getCanvas * @return {HTMLElement} */ getCanvas() { return this._canvas; } /** * Returns the video element * * @method Stage#getVideo * @return {HTMLElement} */ getVideo() { return this._video; } /** * Maximizes an element (with aspect ratio intact) in the viewport via CSS. * * @method Stage.fill * @param {Integer} width The element's original width attribute * @param {Integer} height The element's original height attribute * @param {Integer} viewportWidth The viewport's current width * @param {Integer} viewportHeight The viewport's current height * @return {Object} The new top, left, width, &amp; height */ static fill(width, height, viewportWidth, viewportHeight) { const LANDSCAPE_RATIO = height / width; const PORTRAIT_RATIO = width / height; const IS_LANDSCAPE = LANDSCAPE_RATIO &lt; PORTRAIT_RATIO ? true : false; let winLandscapeRatio = viewportHeight / viewportWidth; let winPortraitRatio = viewportWidth / viewportHeight; let offsetLeft = 0; let offsetTop = 0; let offsetWidth; let offsetHeight; if (IS_LANDSCAPE) { if (LANDSCAPE_RATIO &lt; winLandscapeRatio) { offsetWidth = viewportWidth; offsetHeight = offsetWidth * LANDSCAPE_RATIO; offsetTop = (viewportHeight - offsetHeight) / 2; } else { offsetHeight = viewportHeight; offsetWidth = viewportHeight * PORTRAIT_RATIO; offsetLeft = (viewportWidth - offsetWidth) / 2; } } else { if (PORTRAIT_RATIO &lt; winPortraitRatio) { offsetHeight = viewportHeight; offsetWidth = viewportHeight * PORTRAIT_RATIO; offsetLeft = (viewportWidth - offsetWidth) / 2; } else { offsetWidth = viewportWidth; offsetHeight = offsetWidth * LANDSCAPE_RATIO; offsetTop = (viewportHeight - offsetHeight) / 2; } } return { width: offsetWidth, height: offsetHeight, left: offsetLeft, top: offsetTop }; } /** * Keeps stage element centered in the viewport * * @method Stage.center * @param {Integer} width The element's original width attribute * @param {Integer} height The element's original height attribute * @param {Integer} viewportWidth The viewport's current width * @param {Integer} viewportHeight The viewport's current height * @return {Object} The top and left */ static center(width, height, viewportWidth, viewportHeight) { return { left: (viewportWidth - width) / 2, top: (viewportHeight - height) / 2 }; } } × Search results Close "},"States.js.html":{"id":"States.js.html","title":"Source: States.js","body":" Spritewerk Namespaces bitmapshapetext Classes bitmap.Animationbitmap.BitmapCameraCanvasCollectionGroupInputMobilemodule.exportsPreloaderRadioshape.RectangleSpriteStageStatestext.Texttext.TextInputTicker Source: States.js import Preloader from './Preloader'; /** * @class States * @description Preloads, updates, and cleans up the various game states * Accepts an object of the following schema: &lt;pre&gt;{ // optional property of paths to assets to preload preload: [ 'path/to/assets', ... ], init: function () { // initialize entities etc. }, render: function (factor, ticks) { // do stuff on every tick }, destroy: function () { // remove event listeners } }&lt;/pre&gt; * @author Chris Peters * @requires {@link Preloader} * * @param {Canvas} canvas A Canvas instance * @param {Ticker} ticker A ticker instance */ export default class States { constructor(canvas, ticker) { this._canvas = canvas; this._ticker = ticker; this._loading = false; this._ticker.onTick = this._onTick.bind(this); } /** * Calls the current state's update function. Passes the factor and ticks from {@link Ticker} * * @method States#_onTick * @param {Object} e The event object */ _onTick(factor, ticks) { if (!this._loading &amp;&amp; this._state) { this._canvas.clear(this._state.bgColor); this._canvas.render(this._state, factor, ticks); } } /** * Set up (and preload if necessary) a state * * @method States#load * @return {State} The state to load */ load(state) { this._loading = true; if (this._state) { this._state.destroy(); } this._state = state; if (this._state.preload) { Preloader.complete = ()=&gt; { this._state.init(); this._loading = false; } Preloader.load(this._state.preload); } } } × Search results Close "},"text_index.js.html":{"id":"text_index.js.html","title":"Source: text/index.js","body":" Spritewerk Namespaces bitmapshapetext Classes bitmap.Animationbitmap.BitmapCameraCanvasCollectionGroupInputMobilemodule.exportsPreloaderRadioshape.RectangleSpriteStageStatestext.Texttext.TextInputTicker Source: text/index.js /** * @namespace text */ import Text from './Text'; import TextInput from './TextInput'; × Search results Close "},"text_Text.js.html":{"id":"text_Text.js.html","title":"Source: text/Text.js","body":" Spritewerk Namespaces bitmapshapetext Classes bitmap.Animationbitmap.BitmapCameraCanvasCollectionGroupInputMobilemodule.exportsPreloaderRadioshape.RectangleSpriteStageStatestext.Texttext.TextInputTicker Source: text/Text.js import Sprite from '../Sprite'; /** * @class Text * @memberof text * @desc Renders canvas text * @extends Sprite * @author Chris Peters */ export default class Text extends Sprite { constructor(value = '', x = 0, y = 0) { super(x, y); this._value = value; this._size = 16; this._font = 'sans-serif'; this._baseline = 'top'; this._fill = '#000'; this._stroke = ''; } /** * Returns current text value * * @memberof text * @method Text#getValue * @returns {String} */ getValue() { return this._value; } /*getTextWidth() { return }*/ /** * [setFill description] * * @memberof text * @method Text#setFill * @param {String} val The fill color hex, rgb, rgba, etc. */ setFill(val) { this._fill = val; } /** * [setStroke description] * * @memberof text * @method Text#setStroke * @param {String} val The stroke color hex, rgb, rgba, etc. */ setStroke(val) { this._stroke = val; } /** * * @memberof text * @method Text#setValue * @param {String} val The desired string value */ setValue(val) { this._value = val; } /** * * @memberof text * @method Text#render * @param {Object} context The CanvasRenderingContext2D object * @param {Integer} factor The 0-1-based model of elapsed time * @param {Integer} ticks Total elapsed ticks */ render(context) { super.render(context); context.font = `${this._size}px ${this._font}`; context.textBaseline = this._baseline; if (this._fill) { context.fillStyle = this._fill; context.fillText(this._value, 0, 0); } if (this._stroke) { context.strokeStyle = this._stroke; context.strokeText(this._value, 0, 0); } } } × Search results Close "},"text_TextInput.js.html":{"id":"text_TextInput.js.html","title":"Source: text/TextInput.js","body":" Spritewerk Namespaces bitmapshapetext Classes bitmap.Animationbitmap.BitmapCameraCanvasCollectionGroupInputMobilemodule.exportsPreloaderRadioshape.RectangleSpriteStageStatestext.Texttext.TextInputTicker Source: text/TextInput.js import Text from './Text'; import Rectangle from '../shape/Rectangle'; /** * @class TextInput * @memberof text * @desc Renders strings from off-screen html textfield element into a {@link text.Text} object * @extends Text * @author Chris Peters */ export default class TextInput extends Text { constructor(x = 0, y = 0, opts = {}) { super('', x ,y); this._document = opts.document || document; this._debug = opts.debug; this._lastTick = 0; this._blinkFrames = 30; this._karetShow = true; this._focused = false; this._rect = new Rectangle(); this._textfield = this._document.getElementById('textfield'); this._onChange = this._onChange.bind(this); this._textfield.addEventListener('keyup', this._onChange, false); if (this._debug) { this._textfield.style.top = '16px'; } } /** * * @memberof text * @method TextInput#_onChange * @param {Object} e The event object * @private */ _onChange(e) { this._value = e.target.value; } /** * Blurs the textfield element * * @memberof text * @method TextInput#blur */ blur() { this._textfield.blur(); this._focused = false; } /** * * @memberof text * @method TextInput#destroy */ destroy() { this._textfield.removeEventListener('keyup', this._onChange, false); } /** * Focuses the textfield element * * @memberof text * @method TextInput#focus */ focus() { this._textfield.focus(); this._focused = true; } /** * * @memberof text * @method TextInput#isFocused * @returns {Boolean} */ isFocused() { return this._focused; } /** * * @memberof text * @method TextInput#render * @param {Object} context The CanvasRenderingContext2D object * @param {Integer} factor The 0-1-based model of elapsed time * @param {Integer} ticks Total elapsed ticks */ render(context, factor, tick) { super.render(context, factor, tick); if (tick - this._lastTick &gt;= this._blinkFrames) { this._lastTick = tick; this._karetShow = !this._karetShow; } let textMeasurement = context.measureText(this._value); if (this._karetShow &amp;&amp; this._focused) { context.save(); this._rect.setX(textMeasurement.width + 1); this._rect.setHeight(this._size).setWidth(this._size / 4); this._rect.render(context); context.restore(); } } } × Search results Close "},"Ticker.js.html":{"id":"Ticker.js.html","title":"Source: Ticker.js","body":" Spritewerk Namespaces bitmapshapetext Classes bitmap.Animationbitmap.BitmapCameraCanvasCollectionGroupInputMobilemodule.exportsPreloaderRadioshape.RectangleSpriteStageStatestext.Texttext.TextInputTicker Source: Ticker.js import Radio from './Radio'; /** * @class Ticker * @description Executes callback based on given fps and requestAnimationFrame * @author Chris Peters * @requires Radio * * @param {Boolean} [start] Whether to start on instantiate. Default is true * @param {Object} [opts] Options * @param {Object} [opts.window] window object for testing * @param {Object} [opts.document] document object for testing */ export default class Ticker { constructor(start = true, opts = {}) { this._window = opts.window || window; this._document = opts.document || document; this._then = Date.now(); this._ticks = 0; this._update = this._update.bind(this); if (start) { this._then = Date.now(); this.start(); } } /** * Calculates whether or not to call {@link Ticker#onTick} based on {@link Ticker#_fps}. * If the correct amount of time has passed the {@link Ticker#onTick} callback will fire and * the &lt;code&gt;tick&lt;/code&gt; event will be dispatched via the &lt;code&gt;document&lt;/code&gt; object. * * @method Ticker#_update */ _update() { const now = Date.now(); const delta = (now - this._then) / 1000; this._then = now; this._ticks += 1; const evtObject = { delta: delta, ticks: this._ticks }; // fire tick events and execute callbacks this.onPreTick(delta, this._ticks); Radio.broadcast(this._document, 'pretick', evtObject); this.onTick(delta, this._ticks); Radio.broadcast(this._document, 'tick', evtObject); this.onPostTick(delta, this._ticks); Radio.broadcast(this._document, 'posttick', evtObject); requestAnimationFrame(this._update); } /** * A callback executed pre each tick. * * @method Ticker#onPreTick * @param {Integer} delta The time elapsed between ticks. * Multiply against gameplay elements for consistent * movement. * @param {Integer} ticks The amount of ticks that have accumulated */ onPreTick() {} /** * A callback executed on each tick. * * @method Ticker#onTick * @param {Integer} delta The time elapsed between ticks. * Multiply against gameplay elements for consistent * movement. * @param {Integer} ticks The amount of ticks that have accumulated */ onTick() {} /** * A callback executed post tick. * * @method Ticker#onPostTick * @param {Integer} delta The time elapsed between ticks. * Multiply against gameplay elements for consistent * movement. * @param {Integer} ticks The amount of ticks that have accumulated */ onPostTick() {} /** * Starts the ticker * * @method Ticker#start */ start() { this._then = Date.now(); requestAnimationFrame(this._update); } } × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Spritewerk Namespaces bitmapshapetext Classes bitmap.Animationbitmap.BitmapCameraCanvasCollectionGroupInputMobilemodule.exportsPreloaderRadioshape.RectangleSpriteStageStatestext.Texttext.TextInputTicker Classes Classes Animation Bitmap Camera Canvas Collection Group Input Mobile exports Preloader Radio Rectangle Sprite Stage States Text TextInput Ticker Namespaces bitmap shape text × Search results Close "},"namespaces.list.html":{"id":"namespaces.list.html","title":"Namespaces","body":" Spritewerk Namespaces bitmapshapetext Classes bitmap.Animationbitmap.BitmapCameraCanvasCollectionGroupInputMobilemodule.exportsPreloaderRadioshape.RectangleSpriteStageStatestext.Texttext.TextInputTicker Namespaces Classes Animation Bitmap Camera Canvas Collection Group Input Mobile exports Preloader Radio Rectangle Sprite Stage States Text TextInput Ticker Namespaces bitmap shape text × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" Spritewerk Namespaces bitmapshapetext Classes bitmap.Animationbitmap.BitmapCameraCanvasCollectionGroupInputMobilemodule.exportsPreloaderRadioshape.RectangleSpriteStageStatestext.Texttext.TextInputTicker Spritewerk A small, friendly HTML5 framework for device-agnostic game developmentSpritewerk is a lightweight, fun and easy-to-use solution for producing traditional, console-style games that perform beautifully on any device. The code consists of flexible, generic classes for rapidly developing an HTML5 game. Does not support: physics nested transforms To installgit clone https://github.com/c-concat-p/spritewerk.gitor download archive here. To UseES(6/2015/next)import classes from ./src as needed. ES5Run npm run xpile, then require modules from ./xpile as needed. PlaygroundWant to play with Spritewerk right away? To set up a rather bare-bones development environment run mkdir -p ./playground &amp;&amp; touch ./playground/index.html &amp;&amp; touch ./playground/main.js, and then watch for main.js changes via webpack with: npm run webpackHere is an example main.js file to get you started: import Camera from '../src/Camera'; import Canvas from '../src/Canvas'; import Stage from '../src/Stage'; import Rectangle from '../src/shape/Rectangle'; import Ticker from '../src/Ticker'; const WIDTH = 800; const HEIGHT = 600; let camera = new Camera(); let stage = new Stage(WIDTH, HEIGHT, { bgColor: '#222', fill: true }); let canvas = new Canvas(stage.getCanvas(), camera); let rect = new Rectangle() .setWidth(64) .setHeight(64); let ticker = new Ticker(); let vx = 4; let vy = 4; ticker.onTick = function () { if (rect.getX() &lt; 0) { vx = 4; } if (rect.getX() + rect.getWidth() &gt; WIDTH) { vx = -4; } if (rect.getY() &lt; 0) { vy = 4; } if (rect.getY() + rect.getHeight() &gt; HEIGHT) { vy = -4; } canvas.clear(&quot;#DDD&quot;); rect.translate(vx, vy); canvas.render(rect); };TestTo run Spritewerk's unit tests, first run npm run xpile and then: npm run testDocumentationGenerate the documentation. npm run docBuild(Not for running locally) Jenkins build with code coverage via Coveralls/Istanbul configuration npm run buildTODO support calculating entity's bounding area/position when rotated on an offset pivot support clipping objects copy camera ideas over from old code/ghastlyjs use data/state scaffolding again? reinstate clickCandidate from old code × Search results Close "},"bitmap.html":{"id":"bitmap.html","title":"Namespace: bitmap","body":" Spritewerk Namespaces bitmapshapetext Classes bitmap.Animationbitmap.BitmapCameraCanvasCollectionGroupInputMobilemodule.exportsPreloaderRadioshape.RectangleSpriteStageStatestext.Texttext.TextInputTicker Namespace: bitmap bitmap Source: bitmap/index.js, line 1 Classes Animation Bitmap × Search results Close "},"bitmap.Animation.html":{"id":"bitmap.Animation.html","title":"Class: Animation","body":" Spritewerk Namespaces bitmapshapetext Classes bitmap.Animationbitmap.BitmapCameraCanvasCollectionGroupInputMobilemodule.exportsPreloaderRadioshape.RectangleSpriteStageStatestext.Texttext.TextInputTicker Class: Animation bitmap. Animation new Animation(srcXSequence, srcYSequence, step, loop) Describes the src positions and timing of spritesheet a animation Parameters: Name Type Argument Default Description srcXSequence Array | Integer A list of (or singular) srcX position(s) srcYSequence Array | Integer A list of (or singular) srcY position(s) step Integer &lt;optional&gt; 2 The amount of frames between each frame step. This is based on requestAnimationFrame's 60fps rate. eg: 2 would animate @ 30fps, 3 @ 15fps etc. loop loop &lt;optional&gt; false If true, will start the sequence at the initial position when complete and run until stopped Author: Chris Peters Source: bitmap/Animation.js, line 1 Methods play(loop) Parameters: Name Type Argument Description loop Boolean &lt;optional&gt; Whether or not to loop in this sequence instance Source: bitmap/Animation.js, line 39 stop() Stops the current animation. Called automatically when sequence ends and loop set to false Source: bitmap/Animation.js, line 82 update() Source: bitmap/Animation.js, line 51 Returns: If animation not playing returns null else returns object containing current srcX/Y values Type null | Object × Search results Close "},"bitmap.Bitmap.html":{"id":"bitmap.Bitmap.html","title":"Class: Bitmap","body":" Spritewerk Namespaces bitmapshapetext Classes bitmap.Animationbitmap.BitmapCameraCanvasCollectionGroupInputMobilemodule.exportsPreloaderRadioshape.RectangleSpriteStageStatestext.Texttext.TextInputTicker Class: Bitmap bitmap. Bitmap new Bitmap() A sprite that renders an image asset Author: Chris Peters Source: bitmap/Bitmap.js, line 3 Extends Sprite Members _composite :String The composite operation type. Can be source-atop|source-in|source-out|source-over|destination-atop|destination-in|destination-out|destination-over|lighter|xor|copyDefault is 'source-over' Type: String Inherited From: Sprite#_composite Source: Sprite.js, line 20 Methods getBoundingArea() Inherited From: Sprite#getBoundingArea Source: Sprite.js, line 42 Returns: The bounding area Type Object getComposite() Inherited From: Sprite#getComposite Source: Sprite.js, line 51 Returns: Type String getHeight() Inherited From: Sprite#getHeight Source: Sprite.js, line 59 Returns: Type Integer getOpacity() Inherited From: Sprite#getOpacity Source: Sprite.js, line 67 Returns: Type Float getPivotX() Inherited From: Sprite#getPivotX Source: Sprite.js, line 75 Returns: Type Integer getPivotY() Inherited From: Sprite#getPivotY Source: Sprite.js, line 83 Returns: Type Integer getRotation() Inherited From: Sprite#getRotation Overrides: Sprite#getRotation Source: Sprite.js, line 91 Returns: Type Float getScaleX() Inherited From: Sprite#getScaleX Source: Sprite.js, line 107 Returns: Type Integer getScaleY() Inherited From: Sprite#getScaleY Source: Sprite.js, line 115 Returns: Type Integer getSrcHeight() Inherited From: Sprite#getSrcHeight Source: Sprite.js, line 123 Returns: Type Integer getSrcWidth() Inherited From: Sprite#getSrcWidth Source: Sprite.js, line 131 Returns: Type Integer getSrcX() Inherited From: Sprite#getSrcX Source: Sprite.js, line 139 Returns: Type Integer getSrcY() Inherited From: Sprite#getSrcY Source: Sprite.js, line 147 Returns: Type Integer getWidth() Inherited From: Sprite#getWidth Source: Sprite.js, line 155 Returns: Type Integer getX() Inherited From: Sprite#getX Source: Sprite.js, line 163 Returns: Type Integer getY() Inherited From: Sprite#getY Source: Sprite.js, line 171 Returns: Type Integer render(context) Parameters: Name Type Description context Object The canvas' context Inherited From: Sprite#render Source: Sprite.js, line 179 setComposite(val) Parameters: Name Type Description val Integer The composite value Inherited From: Sprite#setComposite Overrides: Sprite#setComposite Source: Sprite.js, line 197 Returns: Type Sprite setHeight(val) Parameters: Name Type Description val Integer The height value Inherited From: Sprite#setHeight Source: Sprite.js, line 209 Returns: Type Sprite setOpacity(val) Parameters: Name Type Description val Float The opacity value Inherited From: Sprite#setOpacity Source: Sprite.js, line 221 Returns: Type Sprite setPivotX(val) Parameters: Name Type Description val Float The opacity value Inherited From: Sprite#setPivotX Source: Sprite.js, line 233 Returns: Type Sprite setPivotY(val) Parameters: Name Type Description val Float The opacity value Inherited From: Sprite#setPivotY Source: Sprite.js, line 244 Returns: Type Sprite setRotation(val) Parameters: Name Type Description val Integer The rotation value Inherited From: Sprite#setRotation Source: Sprite.js, line 255 Returns: Type Sprite setScaleX(val) Parameters: Name Type Description val Integer The scaleX value Inherited From: Sprite#setScaleX Source: Sprite.js, line 267 Returns: Type Sprite setScaleY(val) Parameters: Name Type Description val Integer The scaleY value Inherited From: Sprite#setScaleY Source: Sprite.js, line 279 Returns: Type Sprite setSrcHeight(val) Parameters: Name Type Description val Integer The srcHeight value Inherited From: Sprite#setSrcHeight Source: Sprite.js, line 291 Returns: Type Sprite setSrcWidth(val) Parameters: Name Type Description val Integer The srcWidth value Inherited From: Sprite#setSrcWidth Source: Sprite.js, line 303 Returns: Type Sprite setSrcX(val) Parameters: Name Type Description val Integer The srcX value Inherited From: Sprite#setSrcX Source: Sprite.js, line 315 Returns: Type Sprite setSrcY(val) Parameters: Name Type Description val Integer The srcY value Inherited From: Sprite#setSrcY Source: Sprite.js, line 327 Returns: Type Sprite setWidth(val) Parameters: Name Type Description val Integer The width value Inherited From: Sprite#setWidth Source: Sprite.js, line 339 Returns: Type Sprite setY(val) Parameters: Name Type Description val Integer The y value Inherited From: Sprite#setY Source: Sprite.js, line 363 Returns: Type Sprite translate(x, y) Add/Subtract current x/y values. Assign any non-number to leave value the same. Parameters: Name Type Argument Description x Integer &lt;optional&gt; y Integer &lt;optional&gt; Inherited From: Sprite#translate Source: Sprite.js, line 375 Returns: Type Sprite × Search results Close "},"Camera.html":{"id":"Camera.html","title":"Class: Camera","body":" Spritewerk Namespaces bitmapshapetext Classes bitmap.Animationbitmap.BitmapCameraCanvasCollectionGroupInputMobilemodule.exportsPreloaderRadioshape.RectangleSpriteStageStatestext.Texttext.TextInputTicker Class: Camera Camera new Camera() Decides what gets rendered Author: Chris Peters Source: Camera.js, line 1 Methods getX() Source: Camera.js, line 12 Returns: Type Integer getY() Source: Camera.js, line 20 Returns: Type Integer setX(val) Parameters: Name Type Description val Integer The x value Source: Camera.js, line 28 Returns: Type Camera setY(val) Parameters: Name Type Description val Integer The y value Source: Camera.js, line 39 Returns: Type Camera × Search results Close "},"Canvas.html":{"id":"Canvas.html","title":"Class: Canvas","body":" Spritewerk Namespaces bitmapshapetext Classes bitmap.Animationbitmap.BitmapCameraCanvasCollectionGroupInputMobilemodule.exportsPreloaderRadioshape.RectangleSpriteStageStatestext.Texttext.TextInputTicker Class: Canvas Canvas new Canvas(canvas, camera) Handles rendering entities onto the canvas element. Parameters: Name Type Description canvas HTMLElement The active canvas element camera Camera The camera instance Author: Chris Peters Source: Canvas.js, line 1 Methods clear(color) Clears the entire canvas and optionally fills with a color Parameters: Name Type Argument Description color String &lt;optional&gt; If passed, will fill the canvas with the color value Source: Canvas.js, line 18 getContext() Returns the context object Source: Canvas.js, line 35 Returns: The 2D context object Type Object render(entity) Offsets canvas based on camera and calls an entity's render method passing the context.Saves and restores context and beginning and end of operation. Parameters: Name Type Description entity Object [description] Source: Canvas.js, line 45 setImageSmoothing(val) Set the context image smoothing Parameters: Name Type Description val Boolean The image smoothing value Source: Canvas.js, line 61 × Search results Close "},"Collection.html":{"id":"Collection.html","title":"Class: Collection","body":" Spritewerk Namespaces bitmapshapetext Classes bitmap.Animationbitmap.BitmapCameraCanvasCollectionGroupInputMobilemodule.exportsPreloaderRadioshape.RectangleSpriteStageStatestext.Texttext.TextInputTicker Class: Collection Collection new Collection() Provides the sortable, iterable storage of entities that are gettable, settable, sortable, removable, etcera(ble) by name Author: Chris Peters Source: Collection.js, line 1 Methods addItem(item, name) Add an item with optional name Parameters: Name Type Argument Description item Any The item to add name String &lt;optional&gt; The optional name of the item Source: Collection.js, line 59 Returns: Type Collection addItems(items) Add multiple items Parameters: Name Type Argument Description items Object &lt;repeatable&gt; Can be the object itself or an object containing the entity and it's name eg: { item: Entity, name: 'entityName' } Source: Collection.js, line 76 Returns: Type Collection each(fn, scope) Iterates the collection's sorted items. The item, index, and name are suppliedto the provided function Parameters: Name Type Argument Description fn function The function to execute on the iterable scope Object &lt;optional&gt; The scope with which to execute the function Source: Collection.js, line 97 filter(fn, scope) iterates items and return the ones that meet criteria Parameters: Name Type Argument Description fn function Truth predicate scope Object &lt;optional&gt; The scope with which to execute the function Source: Collection.js, line 116 Returns: Type Array getItem(name) Returns an existing item by name, or undefined if the name is not found Parameters: Name Type Description name String The name of the item Source: Collection.js, line 147 Returns: Type Any getItemArray() Returns a list of just the items Source: Collection.js, line 135 Returns: Type Array getItemAt(index) Returns an existing item by index Parameters: Name Type Description index Integer Source: Collection.js, line 167 Returns: Type Any getItemCount() Returns the count of items in collection Source: Collection.js, line 176 Returns: Type Integer getItemIndex(name) Returns an item's current index Parameters: Name Type Description name String Source: Collection.js, line 186 Returns: Type Integer removeAllItems() Removes all items from collection Source: Collection.js, line 203 setItem(name, value) Assigns a new value to an existing item Parameters: Name Type Description name String The name of the object to modify value Any The new value Source: Collection.js, line 237 setItemIndex(name, index) Moves item to new index Parameters: Name Type Description name String The name of the object being moved index Integer The item's new index Source: Collection.js, line 254 × Search results Close "},"Group.html":{"id":"Group.html","title":"Class: Group","body":" Spritewerk Namespaces bitmapshapetext Classes bitmap.Animationbitmap.BitmapCameraCanvasCollectionGroupInputMobilemodule.exportsPreloaderRadioshape.RectangleSpriteStageStatestext.Texttext.TextInputTicker Class: Group Group new Group() Provides a transformation hierarchy for Collections Author: Chris Peters Source: Group.js, line 4 Requires: module:Sprite Extends Collection Requires module:Sprite Methods addItem(item, name) Add an item with optional name Parameters: Name Type Argument Description item Any The item to add name String &lt;optional&gt; The optional name of the item Inherited From: Collection#addItem Source: Collection.js, line 59 Returns: Type Collection addItems(items) Add multiple items Parameters: Name Type Argument Description items Object &lt;repeatable&gt; Can be the object itself or an object containing the entity and it's name eg: { item: Entity, name: 'entityName' } Inherited From: Collection#addItems Source: Collection.js, line 76 Returns: Type Collection each(fn, scope) Iterates the collection's sorted items. The item, index, and name are suppliedto the provided function Parameters: Name Type Argument Description fn function The function to execute on the iterable scope Object &lt;optional&gt; The scope with which to execute the function Inherited From: Collection#each Source: Collection.js, line 97 filter(fn, scope) iterates items and return the ones that meet criteria Parameters: Name Type Argument Description fn function Truth predicate scope Object &lt;optional&gt; The scope with which to execute the function Inherited From: Collection#filter Source: Collection.js, line 116 Returns: Type Array getItem(name) Returns an existing item by name, or undefined if the name is not found Parameters: Name Type Description name String The name of the item Inherited From: Collection#getItem Source: Collection.js, line 147 Returns: Type Any getItemArray() Returns a list of just the items Inherited From: Collection#getItemArray Source: Collection.js, line 135 Returns: Type Array getItemAt(index) Returns an existing item by index Parameters: Name Type Description index Integer Inherited From: Collection#getItemAt Source: Collection.js, line 167 Returns: Type Any getItemCount() Returns the count of items in collection Inherited From: Collection#getItemCount Source: Collection.js, line 176 Returns: Type Integer getItemIndex(name) Returns an item's current index Parameters: Name Type Description name String Inherited From: Collection#getItemIndex Source: Collection.js, line 186 Returns: Type Integer removeAllItems() Removes all items from collection Inherited From: Collection#removeAllItems Source: Collection.js, line 203 render(context) Renders all children recursively on top of own transformation stack Parameters: Name Type Description context Object The 2d context object Source: Group.js, line 17 setItem(name, value) Assigns a new value to an existing item Parameters: Name Type Description name String The name of the object to modify value Any The new value Inherited From: Collection#setItem Source: Collection.js, line 237 setItemIndex(name, index) Moves item to new index Parameters: Name Type Description name String The name of the object being moved index Integer The item's new index Inherited From: Collection#setItemIndex Source: Collection.js, line 254 × Search results Close "},"Input.html":{"id":"Input.html","title":"Class: Input","body":" Spritewerk Namespaces bitmapshapetext Classes bitmap.Animationbitmap.BitmapCameraCanvasCollectionGroupInputMobilemodule.exportsPreloaderRadioshape.RectangleSpriteStageStatestext.Texttext.TextInputTicker Class: Input Input new Input(canvas, opts) A module for handling keyboard, mouse, and touch events on the canvas Parameters: Name Type Argument Description canvas HTMLEntity The canvas element to interact with opts Object &lt;optional&gt; Properties Name Type Argument Description canvasFit Boolean &lt;optional&gt; Set to true if using css to fit the canvas in the viewport listenForMouse Boolean &lt;optional&gt; Whether or not to listen for mouse events listenForTouch Boolean &lt;optional&gt; Whether or not to listen for touch events listenForKeyboard Boolean &lt;optional&gt; Whether or not to listen for keyboard events window Object &lt;optional&gt; window object for testing document Object &lt;optional&gt; document object for testing Author: Chris Peters Source: Input.js, line 4 Requires: module:Radio module:lib/keycodes Requires module:Radio module:lib/keycodes Methods _getScaleFactor() get the scale ratio of the canvas based on with/heght attrs and css width/height Source: Input.js, line 130 Returns: Type Float _hitTest(x, y, boundingBox) Checks if point is inside rectangle Parameters: Name Type Description x Integer [description] y Integer [description] boundingBox Object [description] Source: Input.js, line 148 Returns: Type Boolean _onTick(e) Triggers all queued events. Passes the factor and ticks from Ticker Parameters: Name Type Description e Object The event object Source: Input.js, line 294 addListener(type, handler, target) Adds a handler to a Sprite for the given event type Parameters: Name Type Argument Description type string The event type handler function The function to execute when event triggered target object &lt;optional&gt; The target to check event trigger against Source: Input.js, line 335 Returns: Returns true if added and false if callback already exists Type boolean getKeysDown() returns an object of the keys currently being pressedeg: { LEFT_ARROW: 37, UP_ARROW: 38 } Source: Input.js, line 395 Returns: Type Object removeListener(type, handler) Removes matching handler if found Parameters: Name Type Description type string the event type handler function the handler to remove Source: Input.js, line 367 Returns: removed Returns true if removed and otherwise false Type boolean setHitTestMethod(fn) Allows user to set a custom hit test method Parameters: Name Type Description fn function The user's hit test method Source: Input.js, line 406 × Search results Close "},"Mobile.html":{"id":"Mobile.html","title":"Class: Mobile","body":" Spritewerk Namespaces bitmapshapetext Classes bitmap.Animationbitmap.BitmapCameraCanvasCollectionGroupInputMobilemodule.exportsPreloaderRadioshape.RectangleSpriteStageStatestext.Texttext.TextInputTicker Class: Mobile Mobile new Mobile() A class with helpers for making the application play nice with mobile browsers Author: Chris Peters Source: Mobile.js, line 1 Methods &lt;static&gt; addMetaTags(doc) [addMetaTags description] Parameters: Name Type Description doc Object [description] Source: Mobile.js, line 7 × Search results Close "},"module.html#.exports":{"id":"module.html#.exports","title":"Class: exports","body":" Spritewerk Namespaces bitmapshapetext Classes bitmap.Animationbitmap.BitmapCameraCanvasCollectionGroupInputMobilemodule.exportsPreloaderRadioshape.RectangleSpriteStageStatestext.Texttext.TextInputTicker Class: exports exports new exports() Source: tween/Tween.js, line 6 × Search results Close "},"Preloader.html":{"id":"Preloader.html","title":"Class: Preloader","body":" Spritewerk Namespaces bitmapshapetext Classes bitmap.Animationbitmap.BitmapCameraCanvasCollectionGroupInputMobilemodule.exportsPreloaderRadioshape.RectangleSpriteStageStatestext.Texttext.TextInputTicker Class: Preloader Preloader new Preloader() Preloads a list of image, video, and audio files Author: Chris Peters Source: Preloader.js, line 1 Methods &lt;static&gt; _isAudio(path) Returns if file has audio extension Parameters: Name Type Description path String The file path Source: Preloader.js, line 44 Returns: Type Boolean &lt;static&gt; _isImage(path) Returns if file has image extension Parameters: Name Type Description path String The file path Source: Preloader.js, line 57 Returns: Type Boolean &lt;static&gt; _isVideo(path) Returns if file has video extension Parameters: Name Type Description path String The file path Source: Preloader.js, line 72 Returns: Type Boolean &lt;static&gt; error(e) Handles errors Parameters: Name Type Description e Object The event object Source: Preloader.js, line 143 &lt;static&gt; handleLoad(e) Increments loaded count and calls complete or update based on count Parameters: Name Type Description e Object The event object Source: Preloader.js, line 108 &lt;static&gt; load(paths) Parses file types and preloads them via element tags Parameters: Name Type Description paths String | Array File paths to preload Source: Preloader.js, line 7 &lt;static&gt; removeListener(el) Removes event listener when loaded or errored Parameters: Name Type Description el HTMLEntity The html element Source: Preloader.js, line 85 &lt;static&gt; update(loaded, total) Callback executed every time an asset has loaded. It gets passed loaded &amp; totalwhich is useful for displaying percentage feedback. Parameters: Name Type Description loaded Integer total Integer Source: Preloader.js, line 126 × Search results Close "},"Radio.html":{"id":"Radio.html","title":"Class: Radio","body":" Spritewerk Namespaces bitmapshapetext Classes bitmap.Animationbitmap.BitmapCameraCanvasCollectionGroupInputMobilemodule.exportsPreloaderRadioshape.RectangleSpriteStageStatestext.Texttext.TextInputTicker Class: Radio Radio new Radio() Wrapper for event listening, removing, &amp; dispatching. Currently only supports broadcasting Custom and Mouse events Author: Chris Peters Source: Radio.js, line 1 Methods &lt;static&gt; broadcast(target, event, data) Parameters: Name Type Description target Any event String data Object Source: Radio.js, line 27 &lt;static&gt; tuneIn(target, event, callback) Parameters: Name Type Description target Any event String callback function Source: Radio.js, line 7 &lt;static&gt; tuneOut(target, event, callback) Parameters: Name Type Description target Any event String callback function Source: Radio.js, line 17 × Search results Close "},"shape.html":{"id":"shape.html","title":"Namespace: shape","body":" Spritewerk Namespaces bitmapshapetext Classes bitmap.Animationbitmap.BitmapCameraCanvasCollectionGroupInputMobilemodule.exportsPreloaderRadioshape.RectangleSpriteStageStatestext.Texttext.TextInputTicker Namespace: shape shape Source: shape/index.js, line 1 Classes Rectangle × Search results Close "},"shape.Rectangle.html":{"id":"shape.Rectangle.html","title":"Class: Rectangle","body":" Spritewerk Namespaces bitmapshapetext Classes bitmap.Animationbitmap.BitmapCameraCanvasCollectionGroupInputMobilemodule.exportsPreloaderRadioshape.RectangleSpriteStageStatestext.Texttext.TextInputTicker Class: Rectangle shape. Rectangle new Rectangle() A sprite that renders as a rectangle Author: Chris Peters Source: shape/Rectangle.js, line 3 Extends Sprite Members _composite :String The composite operation type. Can be source-atop|source-in|source-out|source-over|destination-atop|destination-in|destination-out|destination-over|lighter|xor|copyDefault is 'source-over' Type: String Inherited From: Sprite#_composite Source: Sprite.js, line 20 Methods getBoundingArea() Inherited From: Sprite#getBoundingArea Source: Sprite.js, line 42 Returns: The bounding area Type Object getComposite() Inherited From: Sprite#getComposite Source: Sprite.js, line 51 Returns: Type String getHeight() Inherited From: Sprite#getHeight Source: Sprite.js, line 59 Returns: Type Integer getOpacity() Inherited From: Sprite#getOpacity Source: Sprite.js, line 67 Returns: Type Float getPivotX() Inherited From: Sprite#getPivotX Source: Sprite.js, line 75 Returns: Type Integer getPivotY() Inherited From: Sprite#getPivotY Source: Sprite.js, line 83 Returns: Type Integer getRotation() Inherited From: Sprite#getRotation Overrides: Sprite#getRotation Source: Sprite.js, line 91 Returns: Type Float getScaleX() Inherited From: Sprite#getScaleX Source: Sprite.js, line 107 Returns: Type Integer getScaleY() Inherited From: Sprite#getScaleY Source: Sprite.js, line 115 Returns: Type Integer getSrcHeight() Inherited From: Sprite#getSrcHeight Source: Sprite.js, line 123 Returns: Type Integer getSrcWidth() Inherited From: Sprite#getSrcWidth Source: Sprite.js, line 131 Returns: Type Integer getSrcX() Inherited From: Sprite#getSrcX Source: Sprite.js, line 139 Returns: Type Integer getSrcY() Inherited From: Sprite#getSrcY Source: Sprite.js, line 147 Returns: Type Integer getWidth() Inherited From: Sprite#getWidth Source: Sprite.js, line 155 Returns: Type Integer getX() Inherited From: Sprite#getX Source: Sprite.js, line 163 Returns: Type Integer getY() Inherited From: Sprite#getY Source: Sprite.js, line 171 Returns: Type Integer render(context, factor, ticks) Parameters: Name Type Description context Object The CanvasRenderingContext2D object factor Integer The 0-1-based model of elapsed time ticks Integer Total elapsed ticks Overrides: Sprite#render Source: shape/Rectangle.js, line 18 setComposite(val) Parameters: Name Type Description val Integer The composite value Inherited From: Sprite#setComposite Overrides: Sprite#setComposite Source: Sprite.js, line 197 Returns: Type Sprite setFill(val) [setFill description] Parameters: Name Type Description val String The fill color hex, rgb, rgba, etc. Source: shape/Rectangle.js, line 43 setHeight(val) Parameters: Name Type Description val Integer The height value Inherited From: Sprite#setHeight Source: Sprite.js, line 209 Returns: Type Sprite setOpacity(val) Parameters: Name Type Description val Float The opacity value Inherited From: Sprite#setOpacity Source: Sprite.js, line 221 Returns: Type Sprite setPivotX(val) Parameters: Name Type Description val Float The opacity value Inherited From: Sprite#setPivotX Source: Sprite.js, line 233 Returns: Type Sprite setPivotY(val) Parameters: Name Type Description val Float The opacity value Inherited From: Sprite#setPivotY Source: Sprite.js, line 244 Returns: Type Sprite setRotation(val) Parameters: Name Type Description val Integer The rotation value Inherited From: Sprite#setRotation Source: Sprite.js, line 255 Returns: Type Sprite setScaleX(val) Parameters: Name Type Description val Integer The scaleX value Inherited From: Sprite#setScaleX Source: Sprite.js, line 267 Returns: Type Sprite setScaleY(val) Parameters: Name Type Description val Integer The scaleY value Inherited From: Sprite#setScaleY Source: Sprite.js, line 279 Returns: Type Sprite setSrcHeight(val) Parameters: Name Type Description val Integer The srcHeight value Inherited From: Sprite#setSrcHeight Source: Sprite.js, line 291 Returns: Type Sprite setSrcWidth(val) Parameters: Name Type Description val Integer The srcWidth value Inherited From: Sprite#setSrcWidth Source: Sprite.js, line 303 Returns: Type Sprite setSrcX(val) Parameters: Name Type Description val Integer The srcX value Inherited From: Sprite#setSrcX Source: Sprite.js, line 315 Returns: Type Sprite setSrcY(val) Parameters: Name Type Description val Integer The srcY value Inherited From: Sprite#setSrcY Source: Sprite.js, line 327 Returns: Type Sprite setStroke(val) [setStroke description] Parameters: Name Type Description val String The stroke color hex, rgb, rgba, etc. Source: shape/Rectangle.js, line 56 setWidth(val) Parameters: Name Type Description val Integer The width value Inherited From: Sprite#setWidth Source: Sprite.js, line 339 Returns: Type Sprite setY(val) Parameters: Name Type Description val Integer The y value Inherited From: Sprite#setY Source: Sprite.js, line 363 Returns: Type Sprite translate(x, y) Add/Subtract current x/y values. Assign any non-number to leave value the same. Parameters: Name Type Argument Description x Integer &lt;optional&gt; y Integer &lt;optional&gt; Inherited From: Sprite#translate Source: Sprite.js, line 375 Returns: Type Sprite × Search results Close "},"Sprite.html":{"id":"Sprite.html","title":"Class: Sprite","body":" Spritewerk Namespaces bitmapshapetext Classes bitmap.Animationbitmap.BitmapCameraCanvasCollectionGroupInputMobilemodule.exportsPreloaderRadioshape.RectangleSpriteStageStatestext.Texttext.TextInputTicker Class: Sprite Sprite new Sprite(x, y) Base class for position based objects Parameters: Name Type Argument Description x Integer &lt;optional&gt; The initial x position. Default is 0 y Integer &lt;optional&gt; The initial y position. Default is 0 Author: Chris Peters Source: Sprite.js, line 1 Members &lt;static&gt; _compositeDefault :String Type: String Source: Sprite.js, line 396 _composite :String The composite operation type. Can be source-atop|source-in|source-out|source-over|destination-atop|destination-in|destination-out|destination-over|lighter|xor|copyDefault is 'source-over' Type: String Source: Sprite.js, line 20 Methods &lt;static&gt; getCompositeDefault() Source: Sprite.js, line 31 Returns: Type String getBoundingArea() Source: Sprite.js, line 42 Returns: The bounding area Type Object getComposite() Source: Sprite.js, line 51 Returns: Type String getHeight() Source: Sprite.js, line 59 Returns: Type Integer getOpacity() Source: Sprite.js, line 67 Returns: Type Float getPivotX() Source: Sprite.js, line 75 Returns: Type Integer getPivotY() Source: Sprite.js, line 83 Returns: Type Integer getRotation() Source: Sprite.js, line 99 Returns: Type Float getRotation() Source: Sprite.js, line 91 Returns: Type Float getScaleX() Source: Sprite.js, line 107 Returns: Type Integer getScaleY() Source: Sprite.js, line 115 Returns: Type Integer getSrcHeight() Source: Sprite.js, line 123 Returns: Type Integer getSrcWidth() Source: Sprite.js, line 131 Returns: Type Integer getSrcX() Source: Sprite.js, line 139 Returns: Type Integer getSrcY() Source: Sprite.js, line 147 Returns: Type Integer getWidth() Source: Sprite.js, line 155 Returns: Type Integer getX() Source: Sprite.js, line 163 Returns: Type Integer getY() Source: Sprite.js, line 171 Returns: Type Integer render(context) Parameters: Name Type Description context Object The canvas' context Source: Sprite.js, line 179 setComposite(val) Parameters: Name Type Description val Integer The x value Source: Sprite.js, line 351 Returns: Type Sprite setComposite(val) Parameters: Name Type Description val Integer The composite value Source: Sprite.js, line 197 Returns: Type Sprite setHeight(val) Parameters: Name Type Description val Integer The height value Source: Sprite.js, line 209 Returns: Type Sprite setOpacity(val) Parameters: Name Type Description val Float The opacity value Source: Sprite.js, line 221 Returns: Type Sprite setPivotX(val) Parameters: Name Type Description val Float The opacity value Source: Sprite.js, line 233 Returns: Type Sprite setPivotY(val) Parameters: Name Type Description val Float The opacity value Source: Sprite.js, line 244 Returns: Type Sprite setRotation(val) Parameters: Name Type Description val Integer The rotation value Source: Sprite.js, line 255 Returns: Type Sprite setScaleX(val) Parameters: Name Type Description val Integer The scaleX value Source: Sprite.js, line 267 Returns: Type Sprite setScaleY(val) Parameters: Name Type Description val Integer The scaleY value Source: Sprite.js, line 279 Returns: Type Sprite setSrcHeight(val) Parameters: Name Type Description val Integer The srcHeight value Source: Sprite.js, line 291 Returns: Type Sprite setSrcWidth(val) Parameters: Name Type Description val Integer The srcWidth value Source: Sprite.js, line 303 Returns: Type Sprite setSrcX(val) Parameters: Name Type Description val Integer The srcX value Source: Sprite.js, line 315 Returns: Type Sprite setSrcY(val) Parameters: Name Type Description val Integer The srcY value Source: Sprite.js, line 327 Returns: Type Sprite setWidth(val) Parameters: Name Type Description val Integer The width value Source: Sprite.js, line 339 Returns: Type Sprite setY(val) Parameters: Name Type Description val Integer The y value Source: Sprite.js, line 363 Returns: Type Sprite translate(x, y) Add/Subtract current x/y values. Assign any non-number to leave value the same. Parameters: Name Type Argument Description x Integer &lt;optional&gt; y Integer &lt;optional&gt; Source: Sprite.js, line 375 Returns: Type Sprite × Search results Close "},"Stage.html":{"id":"Stage.html","title":"Class: Stage","body":" Spritewerk Namespaces bitmapshapetext Classes bitmap.Animationbitmap.BitmapCameraCanvasCollectionGroupInputMobilemodule.exportsPreloaderRadioshape.RectangleSpriteStageStatestext.Texttext.TextInputTicker Class: Stage Stage new Stage(width, height, opts) Creates and handles the canvas element. included in the options parameter is optional dependency injection used for testing against a virtual dom. Parameters: Name Type Argument Description width Integer &lt;optional&gt; The width of the canvas height Integer &lt;optional&gt; The height of the canvas opts Object &lt;optional&gt; Stage options Properties Name Type Argument Description parentEl HTMLElement &lt;optional&gt; The element with which to attach the canvas. If none given the body is used. bgColor String &lt;optional&gt; The parent element's bg color document Object &lt;optional&gt; For testing window Object &lt;optional&gt; For testing fill Boolean &lt;optional&gt; Set to false to not maximally fill viewport. Default is true. Author: Chris Peters Source: Stage.js, line 1 Methods &lt;static&gt; center(width, height, viewportWidth, viewportHeight) Keeps stage element centered in the viewport Parameters: Name Type Description width Integer The element's original width attribute height Integer The element's original height attribute viewportWidth Integer The viewport's current width viewportHeight Integer The viewport's current height Source: Stage.js, line 177 Returns: The top and left Type Object &lt;static&gt; fill(width, height, viewportWidth, viewportHeight) Maximizes an element (with aspect ratio intact) in the viewport via CSS. Parameters: Name Type Description width Integer The element's original width attribute height Integer The element's original height attribute viewportWidth Integer The viewport's current width viewportHeight Integer The viewport's current height Source: Stage.js, line 125 Returns: The new top, left, width, &amp; height Type Object _handleResize() Calls _resizeElement for stage elements Source: Stage.js, line 63 _resizeElement(el) Decides how to handle resize based on options Parameters: Name Type Description el HTMLEntity The element to resize Source: Stage.js, line 73 getCanvas() Returns the canvas element Source: Stage.js, line 105 Returns: Type HTMLElement getVideo() Returns the video element Source: Stage.js, line 115 Returns: Type HTMLElement × Search results Close "},"States.html":{"id":"States.html","title":"Class: States","body":" Spritewerk Namespaces bitmapshapetext Classes bitmap.Animationbitmap.BitmapCameraCanvasCollectionGroupInputMobilemodule.exportsPreloaderRadioshape.RectangleSpriteStageStatestext.Texttext.TextInputTicker Class: States States new States(canvas, ticker) Preloads, updates, and cleans up the various game states Accepts an object of the following schema: { // optional property of paths to assets to preload preload: [ 'path/to/assets', ... ], init: function () { // initialize entities etc. }, render: function (factor, ticks) { // do stuff on every tick }, destroy: function () { // remove event listeners }} Parameters: Name Type Description canvas Canvas A Canvas instance ticker Ticker A ticker instance Author: Chris Peters Source: States.js, line 3 Requires: Preloader Requires Preloader Methods _onTick(e) Calls the current state's update function. Passes the factor and ticks from Ticker Parameters: Name Type Description e Object The event object Source: States.js, line 38 load() Set up (and preload if necessary) a state Source: States.js, line 51 Returns: The state to load Type State × Search results Close "},"text.html":{"id":"text.html","title":"Namespace: text","body":" Spritewerk Namespaces bitmapshapetext Classes bitmap.Animationbitmap.BitmapCameraCanvasCollectionGroupInputMobilemodule.exportsPreloaderRadioshape.RectangleSpriteStageStatestext.Texttext.TextInputTicker Namespace: text text Source: text/index.js, line 1 Classes Text TextInput × Search results Close "},"text.Text.html":{"id":"text.Text.html","title":"Class: Text","body":" Spritewerk Namespaces bitmapshapetext Classes bitmap.Animationbitmap.BitmapCameraCanvasCollectionGroupInputMobilemodule.exportsPreloaderRadioshape.RectangleSpriteStageStatestext.Texttext.TextInputTicker Class: Text text. Text new Text() Renders canvas text Author: Chris Peters Source: text/Text.js, line 3 Extends Sprite Members _composite :String The composite operation type. Can be source-atop|source-in|source-out|source-over|destination-atop|destination-in|destination-out|destination-over|lighter|xor|copyDefault is 'source-over' Type: String Inherited From: Sprite#_composite Source: Sprite.js, line 20 Methods getBoundingArea() Inherited From: Sprite#getBoundingArea Source: Sprite.js, line 42 Returns: The bounding area Type Object getComposite() Inherited From: Sprite#getComposite Source: Sprite.js, line 51 Returns: Type String getHeight() Inherited From: Sprite#getHeight Source: Sprite.js, line 59 Returns: Type Integer getOpacity() Inherited From: Sprite#getOpacity Source: Sprite.js, line 67 Returns: Type Float getPivotX() Inherited From: Sprite#getPivotX Source: Sprite.js, line 75 Returns: Type Integer getPivotY() Inherited From: Sprite#getPivotY Source: Sprite.js, line 83 Returns: Type Integer getRotation() Inherited From: Sprite#getRotation Overrides: Sprite#getRotation Source: Sprite.js, line 91 Returns: Type Float getScaleX() Inherited From: Sprite#getScaleX Source: Sprite.js, line 107 Returns: Type Integer getScaleY() Inherited From: Sprite#getScaleY Source: Sprite.js, line 115 Returns: Type Integer getSrcHeight() Inherited From: Sprite#getSrcHeight Source: Sprite.js, line 123 Returns: Type Integer getSrcWidth() Inherited From: Sprite#getSrcWidth Source: Sprite.js, line 131 Returns: Type Integer getSrcX() Inherited From: Sprite#getSrcX Source: Sprite.js, line 139 Returns: Type Integer getSrcY() Inherited From: Sprite#getSrcY Source: Sprite.js, line 147 Returns: Type Integer getValue() Returns current text value Source: text/Text.js, line 22 Returns: Type String getWidth() Inherited From: Sprite#getWidth Source: Sprite.js, line 155 Returns: Type Integer getX() Inherited From: Sprite#getX Source: Sprite.js, line 163 Returns: Type Integer getY() Inherited From: Sprite#getY Source: Sprite.js, line 171 Returns: Type Integer render(context, factor, ticks) Parameters: Name Type Description context Object The CanvasRenderingContext2D object factor Integer The 0-1-based model of elapsed time ticks Integer Total elapsed ticks Overrides: Sprite#render Source: text/Text.js, line 69 setComposite(val) Parameters: Name Type Description val Integer The composite value Inherited From: Sprite#setComposite Overrides: Sprite#setComposite Source: Sprite.js, line 197 Returns: Type Sprite setFill(val) [setFill description] Parameters: Name Type Description val String The fill color hex, rgb, rgba, etc. Source: text/Text.js, line 37 setHeight(val) Parameters: Name Type Description val Integer The height value Inherited From: Sprite#setHeight Source: Sprite.js, line 209 Returns: Type Sprite setOpacity(val) Parameters: Name Type Description val Float The opacity value Inherited From: Sprite#setOpacity Source: Sprite.js, line 221 Returns: Type Sprite setPivotX(val) Parameters: Name Type Description val Float The opacity value Inherited From: Sprite#setPivotX Source: Sprite.js, line 233 Returns: Type Sprite setPivotY(val) Parameters: Name Type Description val Float The opacity value Inherited From: Sprite#setPivotY Source: Sprite.js, line 244 Returns: Type Sprite setRotation(val) Parameters: Name Type Description val Integer The rotation value Inherited From: Sprite#setRotation Source: Sprite.js, line 255 Returns: Type Sprite setScaleX(val) Parameters: Name Type Description val Integer The scaleX value Inherited From: Sprite#setScaleX Source: Sprite.js, line 267 Returns: Type Sprite setScaleY(val) Parameters: Name Type Description val Integer The scaleY value Inherited From: Sprite#setScaleY Source: Sprite.js, line 279 Returns: Type Sprite setSrcHeight(val) Parameters: Name Type Description val Integer The srcHeight value Inherited From: Sprite#setSrcHeight Source: Sprite.js, line 291 Returns: Type Sprite setSrcWidth(val) Parameters: Name Type Description val Integer The srcWidth value Inherited From: Sprite#setSrcWidth Source: Sprite.js, line 303 Returns: Type Sprite setSrcX(val) Parameters: Name Type Description val Integer The srcX value Inherited From: Sprite#setSrcX Source: Sprite.js, line 315 Returns: Type Sprite setSrcY(val) Parameters: Name Type Description val Integer The srcY value Inherited From: Sprite#setSrcY Source: Sprite.js, line 327 Returns: Type Sprite setStroke(val) [setStroke description] Parameters: Name Type Description val String The stroke color hex, rgb, rgba, etc. Source: text/Text.js, line 48 setValue(val) Parameters: Name Type Description val String The desired string value Source: text/Text.js, line 59 setWidth(val) Parameters: Name Type Description val Integer The width value Inherited From: Sprite#setWidth Source: Sprite.js, line 339 Returns: Type Sprite setY(val) Parameters: Name Type Description val Integer The y value Inherited From: Sprite#setY Source: Sprite.js, line 363 Returns: Type Sprite translate(x, y) Add/Subtract current x/y values. Assign any non-number to leave value the same. Parameters: Name Type Argument Description x Integer &lt;optional&gt; y Integer &lt;optional&gt; Inherited From: Sprite#translate Source: Sprite.js, line 375 Returns: Type Sprite × Search results Close "},"text.TextInput.html":{"id":"text.TextInput.html","title":"Class: TextInput","body":" Spritewerk Namespaces bitmapshapetext Classes bitmap.Animationbitmap.BitmapCameraCanvasCollectionGroupInputMobilemodule.exportsPreloaderRadioshape.RectangleSpriteStageStatestext.Texttext.TextInputTicker Class: TextInput text. TextInput new TextInput() Renders strings from off-screen html textfield element into a text.Text object Author: Chris Peters Source: text/TextInput.js, line 4 Extends Text Methods blur() Blurs the textfield element Source: text/TextInput.js, line 45 destroy() Source: text/TextInput.js, line 56 focus() Focuses the textfield element Source: text/TextInput.js, line 65 isFocused() Source: text/TextInput.js, line 76 Returns: Type Boolean render(context, factor, ticks) Parameters: Name Type Description context Object The CanvasRenderingContext2D object factor Integer The 0-1-based model of elapsed time ticks Integer Total elapsed ticks Source: text/TextInput.js, line 86 × Search results Close "},"Ticker.html":{"id":"Ticker.html","title":"Class: Ticker","body":" Spritewerk Namespaces bitmapshapetext Classes bitmap.Animationbitmap.BitmapCameraCanvasCollectionGroupInputMobilemodule.exportsPreloaderRadioshape.RectangleSpriteStageStatestext.Texttext.TextInputTicker Class: Ticker Ticker new Ticker(start, opts) Executes callback based on given fps and requestAnimationFrame Parameters: Name Type Argument Description start Boolean &lt;optional&gt; Whether to start on instantiate. Default is true opts Object &lt;optional&gt; Options Properties Name Type Argument Description window Object &lt;optional&gt; window object for testing document Object &lt;optional&gt; document object for testing Author: Chris Peters Source: Ticker.js, line 3 Requires: module:Radio Requires module:Radio Methods _update() Calculates whether or not to call Ticker#onTick based on Ticker#_fps.If the correct amount of time has passed the Ticker#onTick callback will fire andthe tick event will be dispatched via the document object. Source: Ticker.js, line 29 onPostTick(delta, ticks) A callback executed post tick. Parameters: Name Type Description delta Integer The time elapsed between ticks. Multiply against gameplay elements for consistent movement. ticks Integer The amount of ticks that have accumulated Source: Ticker.js, line 83 onPreTick(delta, ticks) A callback executed pre each tick. Parameters: Name Type Description delta Integer The time elapsed between ticks. Multiply against gameplay elements for consistent movement. ticks Integer The amount of ticks that have accumulated Source: Ticker.js, line 61 onTick(delta, ticks) A callback executed on each tick. Parameters: Name Type Description delta Integer The time elapsed between ticks. Multiply against gameplay elements for consistent movement. ticks Integer The amount of ticks that have accumulated Source: Ticker.js, line 72 start() Starts the ticker Source: Ticker.js, line 94 × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
